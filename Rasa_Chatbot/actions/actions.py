from typing import List, Dict, Optional
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from actions.graph_connector import GraphConnector
from actions.mapping_utils import normalize_major, normalize_method, normalize_achievement_field, normalize_subject, normalize_faculty  # Import c√°c h√†m ti·ªán √≠ch
import logging
from rasa_sdk.events import SlotSet
from rasa_sdk.events import FollowupAction

# C·∫•u h√¨nh logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

class ActionCutoffScore(Action):
    def name(self) -> str:
        return "action_cutoff_score"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
            
        # L·∫•y d·ªØ li·ªáu t·ª´ tracker
        major_input = tracker.get_slot("major")
        method_input = tracker.get_slot("method")
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng c√°c h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_input)
        method_keyword = normalize_method(method_input)

        print(f"Normalized major: {major_keyword}, Normalized method: {method_keyword}")
        logging.debug(f"Normalized major: {major_keyword}, Normalized method: {method_keyword}")
        
        # Truy v·∫•n v√† x·ª≠ l√Ω k·∫øt qu·∫£
        if major_keyword and method_keyword:
            rows = self.db.get_cutoff_by_major_and_method(major_keyword, method_keyword)
            if rows:
                message = f"**ƒêi·ªÉm chu·∫©n ph∆∞∆°ng th·ª©c {rows[0]['method']} c·ªßa ng√†nh {rows[0]['major']}**:\n"
                for row in rows:
                    message += f"- NƒÉm {row['year']}: {row['score']}\n"
                message += f"Th√≠ sinh c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {rows[0]['majorUrl']} "
            else:
                message = "‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu cho ng√†nh v√† ph∆∞∆°ng th·ª©c b·∫°n y√™u c·∫ßu."

        elif major_keyword:
            rows = self.db.get_all_cutoffs_by_major(major_keyword)
            if rows:
                message = f"üìå **ƒêi·ªÉm chu·∫©n c·ªßa ng√†nh {rows[0]['major']}**:\n"
                grouped = {}
                for row in rows:
                    grouped.setdefault(row["method"], []).append(f"  - NƒÉm {row['year']}: {row['score']}")
                for method, scores in grouped.items():
                    message += f"\nüëâ {method}:\n" + "\n".join(scores)
                message += f"B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {rows[0]['majorUrl']}"
            else:
                message = "‚ùå Kh√¥ng t√¨m th·∫•y ƒëi·ªÉm chu·∫©n cho ng√†nh b·∫°n h·ªèi."

        elif method_keyword:
            rows = self.db.get_all_cutoffs_by_method(method_keyword)
            if rows:
                message = f"üìä **ƒêi·ªÉm chu·∫©n theo ph∆∞∆°ng th·ª©c {method_keyword}**:\n"
                current_major = ""
                for row in rows:
                    if row['major'] != current_major:
                        current_major = row['major']
                        message += f"\nüìå {current_major}:\n"
                    message += f"- NƒÉm {row['year']}: {row['score']}\n"
                message += f"B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin ƒëi·ªÉm chu·∫©n c√°c ph∆∞∆°ng th·ª©c kh√°c /statistics/previous-admission"
            else:
                message = "‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o c√≥ ph∆∞∆°ng th·ª©c tuy·ªÉn sinh n√†y."
        else:
            message = "‚ùó Vui l√≤ng cung c·∫•p t√™n ng√†nh ho·∫∑c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn."

        dispatcher.utter_message(text=message)
        return []

class ActionMajorByMethod(Action):
    def name(self) -> str:
        return "action_major_by_method"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
            
        # S·ª≠ d·ª•ng h√†m normalize_method t·ª´ mapping_utils
        method_keyword = normalize_method(tracker.get_slot("method"))

        if method_keyword:
            rows = self.db.get_major_by_method(method_keyword)
            if rows:
                message = f"üìå **C√°c ng√†nh c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {rows[0]['method']}**:\n"
                for row in rows:
                    message += f"- {row['major']}\n"
                message += f"\nüí° B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn ·ªü {rows[0]['methodUrl']}"
            else:
                message = "‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o c√≥ ph∆∞∆°ng th·ª©c tuy·ªÉn sinh n√†y."
        else:
            message = "‚ùó Vui l√≤ng cung c·∫•p t√™n ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn."

        dispatcher.utter_message(text=message)
        return []
    
class ActionCombinationMajor(Action):
    def name(self) -> str:
        return "action_combination_major"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y th√¥ng tin t·ª´ entity major trong message
        major_entity = next(tracker.get_latest_entity_values("major"), None)
        
        # Chu·∫©n h√≥a t√™n ng√†nh s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_entity)
        
        if major_keyword:
            # Truy v·∫•n d·ªØ li·ªáu t·ªï h·ª£p m√¥n t·ª´ Neo4j
            combinations = self.db.get_combination_subjects(major_keyword)
            
            if combinations and len(combinations) > 0:
                message = f"üìö **T·ªï h·ª£p m√¥n x√©t tuy·ªÉn c·ªßa ng√†nh {combinations[0]['major']}**:\n\n"
                for idx, combo in enumerate(combinations, 1):
                    message += f"{idx}. {combo['subject_combination']}\n"
                message += f"\nüí° *B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin c·ªßa ng√†nh n√†y ·ªü {combinations[0]['majorUrl']} .*"
            else:
                message = f"‚ùó Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ t·ªï h·ª£p m√¥n x√©t tuy·ªÉn cho ng√†nh **{major_keyword}**.\n\nVui l√≤ng ki·ªÉm tra l·∫°i t√™n ng√†nh ho·∫∑c li√™n h·ªá v·ªõi nh√† tr∆∞·ªùng ƒë·ªÉ bi·∫øt th√™m th√¥ng tin."
        else:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n ng√†nh c·ª• th·ªÉ b·∫°n mu·ªën t√¨m hi·ªÉu v·ªÅ t·ªï h·ª£p m√¥n x√©t tuy·ªÉn.\n\nV√≠ d·ª•: *\"T·ªï h·ª£p m√¥n x√©t tuy·ªÉn ng√†nh C√¥ng ngh·ªá th√¥ng tin l√† g√¨?\"*"

        dispatcher.utter_message(text=message)
        return []
    
class ActionAskMethodsForMajor(Action):
    def name(self) -> str:
        return "action_ask_methods_for_major"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y d·ªØ li·ªáu t·ª´ tracker
        major_input = tracker.get_slot("major")
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_input)
        
        print(f"Normalized major for methods: {major_keyword}")
        
        if major_keyword:
            # Truy v·∫•n ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn cho ng√†nh
            results = self.db.get_method_by_major(major_keyword)
            
            if results:
                # T·∫°o th√¥ng b√°o v·ªõi danh s√°ch c√°c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn
                major_name = results[0]["major"]
                methods = [result["method"] for result in results]
                
                message = f"üìù **Ng√†nh {major_name} x√©t tuy·ªÉn b·∫±ng c√°c ph∆∞∆°ng th·ª©c sau:**\n\n"
                
                for i, method in enumerate(methods, 1):
                    message += f"{i}. {method}\n"
                
                if len(methods) == 0:
                    message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn cho ng√†nh {major_input}."
                message += f"üí° B·∫°n c√≥ th·ªÉ xem th√™m th√¥ng tin c·ªßa ng√†nh {results[0]['majorUrl']}"
            else:
                message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn cho ng√†nh {major_input}."
        else:
            message = "‚ùì Vui l√≤ng cung c·∫•p t√™n ng√†nh c·ª• th·ªÉ ƒë·ªÉ t√¥i c√≥ th·ªÉ t√¨m ki·∫øm th√¥ng tin v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn."
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionAskIfMajorAcceptsMethod(Action):
    def name(self) -> str:
        return "action_ask_if_major_accepts_method"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y d·ªØ li·ªáu t·ª´ tracker
        major_input = tracker.get_slot("major")
        method_input = tracker.get_slot("method")
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng c√°c h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_input)
        method_keyword = normalize_method(method_input)
        
        print(f"Normalized major: {major_keyword}, Normalized method: {method_keyword}")
        
        if major_keyword and method_keyword:
            # Ki·ªÉm tra xem ng√†nh c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
            result = self.db.check_major_has_method(major_keyword, method_keyword)
            
            if result["exists"]:
                message = f"‚úÖ **C√≥, ng√†nh {result['major_name']} c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {result['method_name']}.**"
                message += f"\n\nüí° B·∫°n c√≥ th·ªÉ xem th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {result['majorUrl']}"
            else:
                if result["major_name"] and result["method_name"]:
                    message = f"‚ùå **Kh√¥ng, ng√†nh {result['major_name']} kh√¥ng x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {result['method_name']}.**"
                    message += f"\n\nüí° B·∫°n c√≥ th·ªÉ xem th√™m c√°c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn v·ªÅ ng√†nh ·ªü {result['majorUrl']}"
                elif result["major_name"]:
                    message = f"‚ùå **Kh√¥ng t√¨m th·∫•y ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn \"{method_input}\" cho ng√†nh {result['major_name']}.**"
                    message += f"\n\nüí° B·∫°n c√≥ th·ªÉ xem th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {result['majorUrl']}"
                elif result["method_name"]:
                    message = f"‚ùå **Kh√¥ng t√¨m th·∫•y ng√†nh \"{major_input}\" c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {result['method_name']}.**"
                else:
                    message = f"‚ùå **Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ng√†nh \"{major_input}\" v√† ph∆∞∆°ng th·ª©c \"{method_input}\".**"
        else:
            if not major_keyword and not method_keyword:
                message = "‚ùì Vui l√≤ng cung c·∫•p c·∫£ t√™n ng√†nh v√† ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn ƒë·ªÉ t√¥i c√≥ th·ªÉ ki·ªÉm tra."
            elif not major_keyword:
                message = f"‚ùì Vui l√≤ng cung c·∫•p t√™n ng√†nh c·ª• th·ªÉ ƒë·ªÉ t√¥i ki·ªÉm tra c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c \"{method_input}\" kh√¥ng."
            else:
                message = f"‚ùì Vui l√≤ng cung c·∫•p ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn c·ª• th·ªÉ ƒë·ªÉ t√¥i ki·ªÉm tra ng√†nh \"{major_input}\" c√≥ √°p d·ª•ng kh√¥ng."
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionGetMajorQuota(Action):
    def name(self) -> str:
        return "action_get_major_quota"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y th√¥ng tin t·ª´ entity major trong message
        major_entity = next(tracker.get_latest_entity_values("major"), None)
        
        # Chu·∫©n h√≥a t√™n ng√†nh s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_entity)
        
        logging.debug(f"Normalized major for quota: {major_keyword}")
        
        if major_keyword:
            # L·∫•y th√¥ng tin v·ªÅ ch·ªâ ti√™u v√† t√™n ng√†nh t·ª´ Neo4j
            result = self.db.get_major_quota_and_name(major_keyword)
            
            if result["found"]:
                if result["quota"]:
                    message = f"üìä **Ch·ªâ ti√™u tuy·ªÉn sinh ng√†nh {result['name']}**: {result['quota']} sinh vi√™n."
                    message += f"\n\nüí° *L∆∞u √Ω: Ch·ªâ ti√™u c√≥ th·ªÉ thay ƒë·ªïi theo t·ª´ng nƒÉm, b·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m chi ti·∫øt v·ªÅ ng√†nh ·ªü {result['majorUrl']}.*"
                else:
                    message = f"‚ùó Ng√†nh {result['name']} hi·ªán ch∆∞a c√≥ th√¥ng tin v·ªÅ ch·ªâ ti√™u tuy·ªÉn sinh."
            else:
                message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ng√†nh \"{major_entity}\"."
        else:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n ng√†nh c·ª• th·ªÉ b·∫°n mu·ªën bi·∫øt v·ªÅ ch·ªâ ti√™u tuy·ªÉn sinh.\n\nV√≠ d·ª•: *\"Ch·ªâ ti√™u ng√†nh C√¥ng ngh·ªá th√¥ng tin l√† bao nhi√™u?\"*"
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionSuggestMajorByAchievement(Action):
    def name(self) -> str:
        return "action_major_by_achievement"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y th√¥ng tin v·ªÅ th√†nh t√≠ch/s·ªü tr∆∞·ªùng t·ª´ entity
        achievement = next(tracker.get_latest_entity_values("achievement"), None)
        
        logging.debug(f"Achievement input: {achievement}")
        
        if not achievement:
            message = "‚ùì Vui l√≤ng cho bi·∫øt th√†nh t√≠ch, s·ªü tr∆∞·ªùng ho·∫∑c lƒ©nh v·ª±c b·∫°n gi·ªèi ƒë·ªÉ t√¥i c√≥ th·ªÉ g·ª£i √Ω ng√†nh ph√π h·ª£p."
            dispatcher.utter_message(text=message)
            return []
        
        # Chu·∫©n h√≥a v√† ph√¢n lo·∫°i th√†nh t√≠ch/s·ªü tr∆∞·ªùng
        achievement_type = normalize_achievement_field(achievement)
        logging.debug(f"Normalized achievement: {achievement_type}")
        
        # Truy v·∫•n c√°c ng√†nh ph√π h·ª£p v·ªõi th√†nh t√≠ch/s·ªü tr∆∞·ªùng
        majors = self.db.get_major_by_achievement(achievement_type)
        
        if majors:
            message = f"üéØ **D·ª±a tr√™n th√†nh t√≠ch c·ªßa b·∫°n v·ªÅ {achievement_type}, nh·ªØng ng√†nh sau b·∫°n c√≥ th·ªÉ x√©t tuy·ªÉn:**\n\n"
            
            for i, major_info in enumerate(majors, 1):
                message += f"{i}. {major_info['major']}\n"
            
            message += "\nüí° *B·∫°n c√≥ th·ªÉ tham kh·∫£o ph∆∞∆°ng th·ª©c tuy·ªÉn sinh b·∫±ng x√©t tuy·ªÉn ri√™ng ·ªü /admission/xettuyenrieng v√† x√©t tuy·ªÉn th·∫≥ng ·ªü /admission/xettuyenthang *"
        else:
            message = f"‚ùó Th√†nh t√≠ch '{achievement_type} kh√¥ng t√¨m th·∫•y ng√†nh ph√π h·ª£p'.\n\nVui l√≤ng chia s·∫ª th√™m v·ªÅ th√†nh t√≠ch kh√°c ƒë·ªÉ t√¥i t∆∞ v·∫•n t·ªët h∆°n."
        
        dispatcher.utter_message(text=message)
        return []

class ActionDefaultFallback(Action):
    def name(self) -> str:
        return "action_default_fallback"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # ƒê·∫øm s·ªë l·∫ßn fallback li√™n ti·∫øp
        fallback_count = 0
        for event in reversed(tracker.events):
            if event.get("name") == "action_default_fallback":
                fallback_count += 1
            elif event.get("name") not in ["action_listen", None]:
                break
        
        if fallback_count >= 2:
            # N·∫øu fallback nhi·ªÅu l·∫ßn li√™n ti·∫øp -> ƒë·ªÅ ngh·ªã chuy·ªÉn ng∆∞·ªùi h·ªó tr·ª£
            dispatcher.utter_message(
                text="C√≥ v·∫ª nh∆∞ t√¥i kh√¥ng th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa b·∫°n. "
                     "B·∫°n mu·ªën ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi c√°n b·ªô t∆∞ v·∫•n tuy·ªÉn sinh kh√¥ng?")
            
            # ƒê·∫∑t m·ªôt slot ƒë·ªÉ theo d√µi y√™u c·∫ßu handoff
            return [SlotSet("handoff_requested", True)]
        else:
            # Fallback th√¥ng th∆∞·ªùng v·ªõi g·ª£i √Ω
            dispatcher.utter_message(
                text="Xin l·ªói, t√¥i kh√¥ng hi·ªÉu √Ω c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ th·ª≠ c√°c c√¢u h·ªèi nh∆∞:\n"
                     "- ƒêi·ªÉm chu·∫©n ng√†nh C√¥ng ngh·ªá th√¥ng tin nƒÉm 2024?\n"
                     "- Ng√†nh CNTT ƒë·∫∑c th√π l√† g√¨?\n"
                     "- T·ªï h·ª£p m√¥n x√©t tuy·ªÉn ng√†nh CNTT?\n"
                     "- C√°c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn nƒÉm nay l√† g√¨?")
            
            return []

# Th√™m action handoff ƒë√£ ƒëi·ªÅu ch·ªânh
class ActionHandoffToHuman(Action):
    def name(self) -> str:
        return "action_handoff_to_human"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # Th√¥ng b√°o h∆∞·ªõng d·∫´n theo y√™u c·∫ßu
        dispatcher.utter_message(
            text="ƒê·ªÉ k·∫øt n·ªëi v·ªõi c√°n b·ªô t∆∞ v·∫•n, vui l√≤ng truy c·∫≠p v√†o m·ª•c t∆∞ v·∫•n tuy·ªÉn sinh tr√™n website.")
        
        # Reset slot handoff_requested
        return [SlotSet("handoff_requested", False)]

# Th√™m action tr√≠ch xu·∫•t th√¥ng tin t·ª´ ng·ªØ c·∫£nh
class ActionExtractFromContext(Action):
    def name(self) -> str:
        return "action_extract_from_context"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y message hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng
        user_message = tracker.latest_message.get("text", "").lower()
        
        # Tr√≠ch xu·∫•t ng·ªØ c·∫£nh hi·ªán t·∫°i
        current_major = tracker.get_slot("current_context_major")
        current_method = tracker.get_slot("current_context_method")
        
        # C√°c t·ª´ kh√≥a x√°c nh·∫≠n/ph·ªß ƒë·ªãnh
        affirm_keywords = ["c√≥", "ƒë√∫ng", "v√¢ng", "ok", "ƒë∆∞·ª£c", "mu·ªën", "t·∫•t nhi√™n", "ch·∫Øc ch·∫Øn"]
        deny_keywords = ["kh√¥ng", "ƒë·ª´ng", "th√¥i", "kh·ªèi", "ch∆∞a", "kh√¥ng c·∫ßn"]
        
        # Ki·ªÉm tra n·∫øu c√≥ x√°c nh·∫≠n/ph·ªß ƒë·ªãnh trong tin nh·∫Øn
        is_affirm = any(keyword in user_message for keyword in affirm_keywords)
        is_deny = any(keyword in user_message for keyword in deny_keywords)
        
        # N·∫øu c√≥ x√°c nh·∫≠n v√† ƒëang c√≥ major trong ng·ªØ c·∫£nh
        if is_affirm and current_major:
            if "t·ªï h·ª£p" in user_message or "m√¥n" in user_message:
                # Chuy·ªÉn h∆∞·ªõng sang action tr·∫£ l·ªùi v·ªÅ t·ªï h·ª£p m√¥n
                return [FollowupAction("action_combination_major")]
            
            elif "ph∆∞∆°ng th·ª©c" in user_message or "x√©t tuy·ªÉn" in user_message:
                # Chuy·ªÉn sang tr·∫£ l·ªùi v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn
                return [FollowupAction("action_ask_methods_for_major")]
        
        # N·∫øu ph·ªß ƒë·ªãnh ho·∫∑c kh√¥ng r√µ √Ω ng∆∞·ªùi d√πng
        if is_deny or not (is_affirm or is_deny):
            dispatcher.utter_message(
                text="B·∫°n c·∫ßn t∆∞ v·∫•n th√™m th√¥ng tin g√¨ v·ªÅ tuy·ªÉn sinh?")
        
        return []

class ActionSuggestMajorBySubjects(Action):
    def name(self) -> str:
        return "action_suggest_major_by_subjects"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y t·∫•t c·∫£ c√°c entity subject t·ª´ message hi·ªán t·∫°i
        subjects = list(tracker.get_latest_entity_values("subject"))
        
        logging.debug(f"Raw subjects from entities: {subjects}")
        
        # N·∫øu kh√¥ng t√¨m th·∫•y subject trong entities, th·ª≠ t√¨m trong to√†n b·ªô message
        if not subjects:
            user_message = tracker.latest_message.get("text", "")
            from actions.mapping_utils import find_subjects_in_text
            subjects = find_subjects_in_text(user_message)
            logging.debug(f"Subjects extracted from message: {subjects}")
        
        # Chu·∫©n h√≥a c√°c m√¥n h·ªçc
        normalized_subjects = []
        for subject in subjects:
            normalized_subject = normalize_subject(subject)
            if normalized_subject and normalized_subject not in normalized_subjects:
                normalized_subjects.append(normalized_subject)
        
        logging.debug(f"Normalized subjects: {normalized_subjects}")
        
        if not normalized_subjects:
            message = "‚ùì Vui l√≤ng cho bi·∫øt c√°c m√¥n h·ªçc b·∫°n mu·ªën x√©t tuy·ªÉn ƒë·ªÉ t√¥i c√≥ th·ªÉ g·ª£i √Ω ng√†nh ph√π h·ª£p.\n\n" \
                      "V√≠ d·ª•: \"*T√¥i mu·ªën x√©t tuy·ªÉn b·∫±ng m√¥n To√°n, L√Ω, H√≥a th√¨ c√≥ th·ªÉ ƒëƒÉng k√Ω ng√†nh n√†o?*\""
            dispatcher.utter_message(text=message)
            return []
        
        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng m√¥n h·ªçc t·ªëi ƒëa l√† 4
        if len(normalized_subjects) > 4:
            normalized_subjects = normalized_subjects[:4]
            logging.debug(f"Limited to max 4 subjects: {normalized_subjects}")
        
        # Truy v·∫•n c√°c ng√†nh ph√π h·ª£p v·ªõi c√°c m√¥n h·ªçc ƒë√£ chu·∫©n h√≥a
        majors = self.db.get_majors_by_subjects(normalized_subjects)
        logging.debug(f"Got {len(majors)} results from Neo4j")
        
        if majors:
            # Danh s√°ch c√°c m√¥n ƒë√£ ch·ªçn
            subjects_str = ", ".join([f"**{subject}**" for subject in normalized_subjects])
            
            message = f"üìö **C√°c ng√†nh ph√π h·ª£p v·ªõi m√¥n {subjects_str}:**\n\n"
            
            # X·ª≠ l√Ω k·∫øt qu·∫£ tr·ª±c ti·∫øp t·ª´ Neo4j, kh√¥ng c·∫ßn gom nh√≥m l·∫°i
            major_count = 0
            for i, record in enumerate(majors, 1):
                # Chuy·ªÉn Neo4j record th√†nh dict ƒë·ªÉ d·ªÖ x·ª≠ l√Ω
                major_info = dict(record)
                
                # L·∫•y th√¥ng tin c∆° b·∫£n
                major_name = major_info.get('major')
                major_id = major_info.get('major_id')
                
                if not major_name:
                    continue
                
                major_count += 1
                message += f"{major_count}. **{major_name}**\n"
                
                # X·ª≠ l√Ω v√† hi·ªÉn th·ªã c√°c t·ªï h·ª£p m√¥n
                subject_combinations = major_info.get('subject_combinations', [])
                
                if subject_combinations and len(subject_combinations) > 0:
                    message += "   *T·ªï h·ª£p m√¥n*:\n"
                    for combo in subject_combinations:
                        message += f"   - {combo}\n"
                else:
                    message += "   *T·ªï h·ª£p m√¥n*: Th√¥ng tin kh√¥ng c√≥ s·∫µn\n"
                
                message += "\n"
                
            
            # Th√™m g·ª£i √Ω
            message += "\nüí° B·∫°n c√≥ th·ªÉ xem chi ti·∫øt v·ªÅ ph∆∞∆°ng th·ª©c x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp trung h·ªçc ph·ªï th√¥ng /admission/totnghiep_thpt"
        else:
            subjects_str = ", ".join(normalized_subjects)
            message = f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o ph√π h·ª£p v·ªõi m√¥n **{subjects_str}**.\n\n" \
                      f"C√≥ th·ªÉ t·ªï h·ª£p m√¥n n√†y kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong x√©t tuy·ªÉn ho·∫∑c th√¥ng tin ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong h·ªá th·ªëng.\n\n" \
                      f"üí° B·∫°n c√≥ th·ªÉ th·ª≠ v·ªõi c√°c m√¥n ph·ªï bi·∫øn nh∆∞: **To√°n, L√Ω, H√≥a** ho·∫∑c **To√°n, VƒÉn, Anh**."
        
        dispatcher.utter_message(text=message)
        
        # L∆∞u l·∫°i b·ªëi c·∫£nh ƒë·ªÉ x·ª≠ l√Ω theo d√µi
        if "current_subjects" in domain.get("slots", {}):
            return [SlotSet("current_subjects", normalized_subjects)]
        return []
    
class ActionGetMajorsByFaculty(Action):
    def name(self) -> str:
        return "action_get_majors_by_faculty"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y faculty t·ª´ entity ho·∫∑c slot
        faculty_entity = next(tracker.get_latest_entity_values("faculty"), None)
        faculty_slot = tracker.get_slot("faculty")
        
        # ∆Øu ti√™n entity trong message hi·ªán t·∫°i, n·∫øu kh√¥ng c√≥ th√¨ d√πng slot
        faculty = faculty_entity or faculty_slot
        
        logging.debug(f"Faculty input: {faculty}")
        
        if not faculty:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n khoa b·∫°n mu·ªën t√¨m hi·ªÉu v·ªÅ c√°c ng√†nh ƒë√†o t·∫°o.\n\n" \
                      "V√≠ d·ª•: \"*Khoa C√¥ng ngh·ªá th√¥ng tin c√≥ nh·ªØng ng√†nh n√†o?*\" ho·∫∑c \"*C√°c ng√†nh thu·ªôc khoa ƒêi·ªán?*\""
            dispatcher.utter_message(text=message)
            return []
        
        # Chu·∫©n h√≥a faculty ƒë·ªÉ l·∫•y ID
        faculty_id = normalize_faculty(faculty)
        faculty_id = int(faculty_id)
        logging.debug(f"Normalized faculty ID: {faculty_id}")
        
        if not faculty_id:
            message = f"‚ùå T√¥i kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ Khoa \"{faculty}\". Vui l√≤ng ki·ªÉm tra l·∫°i t√™n khoa."
            dispatcher.utter_message(text=message)
            return []
            
        # L·∫•y danh s√°ch ng√†nh t·ª´ khoa
        majors = self.db.get_majors_by_faculty(faculty_id)
        
        if not majors or len(majors) == 0:
            message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ c√°c ng√†nh thu·ªôc Khoa n√†y. C√≥ th·ªÉ d·ªØ li·ªáu ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t."
            dispatcher.utter_message(text=message)
            return []
            
        # T·∫°o message hi·ªÉn th·ªã danh s√°ch ng√†nh
        faculty_name = majors[0]["faculty"]
        message = f"üè´ **C√°c ng√†nh ƒë√†o t·∫°o thu·ªôc khoa {faculty_name}:**\n\n"
        
        for i, major in enumerate(majors, 1):
            message += f"{i}. **{major['major']}**\n"
            
        message += "\nüí° *B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ ƒëi·ªÉm chu·∫©n, t·ªï h·ª£p m√¥n ho·∫∑c th√¥ng tin chi ti·∫øt c·ªßa t·ª´ng ng√†nh.*"
        
        dispatcher.utter_message(text=message)
        
        # L∆∞u th√¥ng tin v√†o slot ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
        return []
    
class ActionSuggestMajorByScore(Action):
    def name(self) -> str:
        return "action_suggest_major_by_score"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y ƒëi·ªÉm s·ªë t·ª´ entity
        score_entity = next(tracker.get_latest_entity_values("score"), None)
        
        # L·∫•y ph∆∞∆°ng th·ª©c t·ª´ entity v√† chu·∫©n h√≥a
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        
        if not score_entity:
            dispatcher.utter_message(text="‚ùì Vui l√≤ng cho bi·∫øt s·ªë ƒëi·ªÉm b·∫°n ƒë·∫°t ƒë∆∞·ª£c.")
            return []
        
        if not method_entity:
            dispatcher.utter_message(text="‚ùì Vui l√≤ng cho bi·∫øt ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn b·∫°n quan t√¢m.")
            return []
        
        try:
            # Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm sang s·ªë
            score = float(score_entity)
            
            # Chu·∫©n h√≥a ph∆∞∆°ng th·ª©c
            method_id = normalize_method(method_entity)
            
            if not method_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra ph∆∞∆°ng th·ª©c '{method_entity}'. "
                                            f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, "
                                            f"x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c, ƒë√°nh gi√° t∆∞ duy ho·∫∑c x√©t tuy·ªÉn ri√™ng.")
                return []
            
            # L·∫•y k·∫øt qu·∫£ g·ª£i √Ω ng√†nh
            results = self.db.get_majors_by_score_and_method(score, method_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o ph√π h·ª£p v·ªõi ƒëi·ªÉm s·ªë {score} "
                                            f"theo ph∆∞∆°ng th·ª©c {method_entity}.")
                return []
            
            # L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
            results = self._filter_valid_majors(results, method_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå T√¥i ƒë√£ t√¨m th·∫•y m·ªôt s·ªë ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm s·ªë c·ªßa b·∫°n, "
                                            f"nh∆∞ng kh√¥ng c√≥ ng√†nh n√†o c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c {method_entity} "
                                            f"trong nƒÉm h·ªçc hi·ªán t·∫°i.")
                return []
            
            # T·∫°o ph·∫£n h·ªìi
            message = self._create_response_message(results, score, method_entity)
            
            dispatcher.utter_message(text=message)
            
            return [
                SlotSet("score", score_entity),
                SlotSet("method", method_entity)
            ]
            
        except ValueError:
            dispatcher.utter_message(text=f"‚ùå ƒêi·ªÉm s·ªë '{score_entity}' kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë.")
            return []
    
    def _filter_valid_majors(self, grouped_results: list, method_id: str) -> list:
        """
        L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
        """
        if not grouped_results:
            return []
        
        filtered_groups = []
        
        for group in grouped_results:
            valid_majors = []
            for major in group["majors"]:
                # Ki·ªÉm tra xem ng√†nh c√≥ c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
                check_result = self.db.check_major_has_method(major["major_id"], method_id)
                
                # N·∫øu ph∆∞∆°ng th·ª©c v·∫´n ƒë∆∞·ª£c √°p d·ª•ng, gi·ªØ l·∫°i ng√†nh n√†y
                if check_result["exists"]:
                    valid_majors.append(major)
                else:
                    logging.debug(f"Major {major['major_name']} ({major['major_id']}) no longer uses method {method_id}")
            
            # Ch·ªâ th√™m nh√≥m v√†o k·∫øt qu·∫£ n·∫øu c√≥ ng√†nh h·ª£p l·ªá
            if valid_majors:
                filtered_groups.append({
                    "group": group["group"],
                    "majors": valid_majors
                })
        
        return filtered_groups
    
    def _create_response_message(self, grouped_results: list, score: float, method: str) -> str:
        """
        T·∫°o th√¥ng ƒëi·ªáp ph·∫£n h·ªìi t·ª´ k·∫øt qu·∫£ ƒë√£ nh√≥m
        """
        message = f"üìä **C√°c ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} theo ph∆∞∆°ng th·ª©c {method}:**\n\n"
        
        # Th√¥ng tin v·ªÅ c√°c nh√≥m
        group_info = {
            "high": "üî• **T·ª∑ l·ªá ƒë·ªó cao**",
            "medium": "‚ö° **T·ª∑ l·ªá ƒë·ªó trung b√¨nh**",
            "low": "‚ö†Ô∏è **T·ª∑ l·ªá ƒë·ªó th·∫•p**"
        }
        
        for group in grouped_results:
            group_name = group["group"]
            majors = group["majors"]
            
            if majors:
                message += f"{group_info.get(group_name, 'Kh√°c')}:\n\n"
                
                for i, major in enumerate(majors, 1):
                    message += f"{i}. **{major['major_name']}**\n"
                    message += f"   - ƒêi·ªÉm chu·∫©n: {major['cutoff']} ({major['year']})\n"
                
                message += "\n"
        
        message += "üí° *Ghi ch√∫: C√°c ng√†nh ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·ªÅu √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm h·ªçc hi·ªán t·∫°i. K·∫øt qu·∫£ d·ª±a tr√™n ƒëi·ªÉm chu·∫©n c√°c nƒÉm tr∆∞·ªõc.*\n\n"
        message += "B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ:\n"
        message += "- T·ªï h·ª£p m√¥n x√©t tuy·ªÉn c·ªßa ng√†nh\n"
        message += "- ƒêi·ªÉm chu·∫©n c·ªßa ng√†nh theo c√°c nƒÉm"
        
        
        return message
    
class ActionSuggestMajorByScoreWithMethodAndFaculty(Action):
    def name(self) -> str:
        return "action_suggest_major_by_score_with_method_and_faculty"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y c√°c entity t·ª´ message
        score_entity = next(tracker.get_latest_entity_values("score"), None)
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        faculty_entity = next(tracker.get_latest_entity_values("faculty"), None)
        
        # Ki·ªÉm tra c√°c entity c·∫ßn thi·∫øt
        missing_entities = []
        if not score_entity:
            missing_entities.append("ƒëi·ªÉm s·ªë")
        if not method_entity:
            missing_entities.append("ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn")
        if not faculty_entity:
            missing_entities.append("khoa")
            
        if missing_entities:
            missing_str = ", ".join(missing_entities)
            message = f"‚ùì Vui l√≤ng cung c·∫•p {missing_str} ƒë·ªÉ t√¥i c√≥ th·ªÉ t∆∞ v·∫•n ng√†nh ph√π h·ª£p."
            dispatcher.utter_message(text=message)
            return []
        
        try:
            # Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm sang s·ªë
            score = float(score_entity)
            
            # Chu·∫©n h√≥a ph∆∞∆°ng th·ª©c v√† khoa
            method_id = normalize_method(method_entity)
            faculty_id = normalize_faculty(faculty_entity)
            faculty_id = int(faculty_id)
            
            if not method_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra ph∆∞∆°ng th·ª©c '{method_entity}'. "
                                            f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, "
                                            f"x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c, ƒë√°nh gi√° t∆∞ duy ho·∫∑c x√©t tuy·ªÉn ri√™ng.")
                return []
                
            if not faculty_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra khoa '{faculty_entity}'. "
                                            f"Vui l√≤ng ki·ªÉm tra l·∫°i t√™n khoa.")
                return []
            
            # L·∫•y k·∫øt qu·∫£ g·ª£i √Ω ng√†nh
            results = self.db.get_majors_by_score_method_and_faculty(score, method_id, faculty_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o thu·ªôc khoa n√†y c√≥ ƒëi·ªÉm chu·∫©n "
                                            f"theo ph∆∞∆°ng th·ª©c {method_entity}.")
                return []
            
            # L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
            results = self._filter_valid_majors(results, method_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå T√¥i ƒë√£ t√¨m th·∫•y m·ªôt s·ªë ng√†nh thu·ªôc khoa n√†y, "
                                            f"nh∆∞ng kh√¥ng c√≥ ng√†nh n√†o c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c {method_entity} "
                                            f"trong nƒÉm h·ªçc hi·ªán t·∫°i.")
                return []
            
            # T√¨m t√™n khoa ƒë·ªÉ hi·ªÉn th·ªã
            faculty_name = None
            for group in results:
                for major in group["majors"]:
                    # L·∫•y t√™n khoa t·ª´ b·∫•t k·ª≥ major n√†o
                    faculty_name_query = self.db.get_faculty_name_by_id(faculty_id)
                    if faculty_name_query:
                        faculty_name = faculty_name_query
                        break
                if faculty_name:
                    break
            
            if not faculty_name:
                faculty_name = faculty_entity
            
            # T·∫°o ph·∫£n h·ªìi
            message = self._create_response_message(results, score, method_entity, faculty_name)
            
            dispatcher.utter_message(text=message)
            
            return []
            
        except ValueError:
            dispatcher.utter_message(text=f"‚ùå ƒêi·ªÉm s·ªë '{score_entity}' kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë.")
            return []
    
    def _filter_valid_majors(self, grouped_results: list, method_id: str) -> list:
        """
        L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
        """
        if not grouped_results:
            return []
        
        filtered_groups = []
        
        for group in grouped_results:
            valid_majors = []
            for major in group["majors"]:
                # Ki·ªÉm tra xem ng√†nh c√≥ c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
                check_result = self.db.check_major_has_method(major["major_id"], method_id)
                
                # N·∫øu ph∆∞∆°ng th·ª©c v·∫´n ƒë∆∞·ª£c √°p d·ª•ng, gi·ªØ l·∫°i ng√†nh n√†y
                if check_result["exists"]:
                    valid_majors.append(major)
                else:
                    logging.debug(f"Major {major['major_name']} ({major['major_id']}) no longer uses method {method_id}")
            
            # Ch·ªâ th√™m nh√≥m v√†o k·∫øt qu·∫£ n·∫øu c√≥ ng√†nh h·ª£p l·ªá
            if valid_majors:
                filtered_groups.append({
                    "group": group["group"],
                    "majors": valid_majors
                })
        
        return filtered_groups
    
    def _create_response_message(self, grouped_results: list, score: float, method: str, faculty_name: str) -> str:
        """
        T·∫°o th√¥ng ƒëi·ªáp ph·∫£n h·ªìi t·ª´ k·∫øt qu·∫£ ƒë√£ nh√≥m
        """
        message = f"üìä **C√°c ng√†nh thu·ªôc khoa {faculty_name} ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} theo ph∆∞∆°ng th·ª©c {method}:**\n\n"
        
        # Th√¥ng tin v·ªÅ c√°c nh√≥m
        group_info = {
            "high": "üî• **Kh·∫£ nƒÉng ƒë·ªó cao**",
            "medium": "‚ö° **Kh·∫£ nƒÉng ƒë·ªó trung b√¨nh**",
            "low": "‚ö†Ô∏è **Kh·∫£ nƒÉng ƒë·ªó th·∫•p**"
        }
        
        group_desc = {
            "high": "*(ƒêi·ªÉm c·ªßa b·∫°n >= ƒëi·ªÉm chu·∫©n)*",
            "medium": "*(ƒêi·ªÉm c·ªßa b·∫°n < ƒëi·ªÉm chu·∫©n, ch√™nh l·ªách √≠t)*",
            "low": "*(ƒêi·ªÉm c·ªßa b·∫°n < ƒëi·ªÉm chu·∫©n, ch√™nh l·ªách nhi·ªÅu)*"
        }
        
        for group in grouped_results:
            group_name = group["group"]
            majors = group["majors"]
            
            if majors:
                message += f"{group_info.get(group_name, 'Kh√°c')} {group_desc.get(group_name, '')}:\n\n"
                
                for i, major in enumerate(majors, 1):
                    message += f"{i}. **{major['major_name']}**\n"
                    message += f"   - ƒêi·ªÉm chu·∫©n: {major['cutoff']} ({major['year']})\n"
                
                message += "\n"
        
        message += "üí° *Ghi ch√∫: C√°c ng√†nh ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·ªÅu √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm h·ªçc hi·ªán t·∫°i. K·∫øt qu·∫£ d·ª±a tr√™n ƒëi·ªÉm chu·∫©n c√°c nƒÉm tr∆∞·ªõc.*\n\n"
        message += "B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ:\n"
        message += "- T·ªï h·ª£p m√¥n x√©t tuy·ªÉn c·ªßa ng√†nh\n"
        message += "- C∆° h·ªôi vi·ªác l√†m c·ªßa c√°c ng√†nh n√†y"
        
        return message
    
class ActionGetAdmissionProcessByMethod(Action):
    def name(self) -> str:
        return "action_get_admission_process_by_method"

    def __init__(self):
        self.admission_processes = {
            "xtt": self._get_xet_tuyen_thang_process(),
            "xtr": self._get_xet_tuyen_rieng_process(),
            "tn_thpt": self._get_tot_nghiep_thpt_process(),
            "hb_thpt": self._get_hoc_ba_process(),
            "dgnl": self._get_danh_gia_nang_luc_process(),
            "dgtd": self._get_danh_gia_tu_duy_process()
        }
        
        self.method_urls = {
            "xtt": "/admission/xettuyenthang",
            "xtr": "/admission/xettuyenrieng",
            "tn_thpt": "/admission/totnghiep_thpt",
            "hb_thpt": "/admission/hocba_thpt",
            "dgnl": "/admission/danhgianangluc",
            "dgtd": "/admission/danhgiatuduy"
        }

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
            
        # L·∫•y ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn t·ª´ entity ho·∫∑c slot
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        method_slot = tracker.get_slot("method")
        
        # ∆Øu ti√™n entity trong message hi·ªán t·∫°i, n·∫øu kh√¥ng c√≥ th√¨ d√πng slot
        method = method_entity or method_slot
        
        if not method:
            dispatcher.utter_message(text="‚ùì Vui l√≤ng cho bi·∫øt ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn b·∫°n mu·ªën t√¨m hi·ªÉu quy tr√¨nh ƒëƒÉng k√Ω.")
            return []
        
        # Chu·∫©n h√≥a method ƒë·ªÉ l·∫•y ID
        method_id = normalize_method(method)
        
        if not method_id or method_id not in self.admission_processes:
            message = (f"‚ùå T√¥i kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ quy tr√¨nh ƒëƒÉng k√Ω cho ph∆∞∆°ng th·ª©c \"{method}\". "
                      f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t tuy·ªÉn th·∫≥ng, x√©t tuy·ªÉn ri√™ng, "
                      f"x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c ho·∫∑c ƒë√°nh gi√° t∆∞ duy.")
            dispatcher.utter_message(text=message)
            return []
        
        # L·∫•y quy tr√¨nh ƒëƒÉng k√Ω cho ph∆∞∆°ng th·ª©c t∆∞∆°ng ·ª©ng
        process_message = self.admission_processes[method_id]
        
        # L·∫•y URL t∆∞∆°ng ·ª©ng cho ph∆∞∆°ng th·ª©c
        method_url = self.method_urls.get(method_id, "")
        
        # Th√™m th√¥ng tin chi ti·∫øt v·ªÅ ƒë∆∞·ªùng d·∫´n sau ph·∫ßn document
        additional_info = f"\n\nChi ti·∫øt c√°c ng√†nh x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c n√†y t·∫°i {method_url}"
        
        # G·ª≠i c·∫£ tin nh·∫Øn v√† th√™m th√¥ng tin ƒë∆∞·ªùng d·∫´n
        dispatcher.utter_message(text=process_message + additional_info)
        
        # L∆∞u slot ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
        return []
    
    def _get_xet_tuyen_thang_process(self) -> str:
        intro = "C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t tuy·ªÉn th·∫≥ng:"
        
        document_content = """
# C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t tuy·ªÉn th·∫≥ng:

## Quy tr√¨nh ƒëƒÉng k√Ω v√† n·ªôp h·ªì s∆°:

1. **ƒêƒÉng k√Ω tr·ª±c tuy·∫øn**: Th√≠ sinh ƒëƒÉng k√Ω tr·ª±c tuy·∫øn t·∫°i ƒë∆∞·ªùng d·∫´n https://tuyensinh.dut.udn.vn/

2. **S·ªë l∆∞·ª£ng nguy·ªán v·ªçng**: 
   - M·ªói th√≠ sinh ch·ªâ ƒë∆∞·ª£c ƒëƒÉng k√Ω duy nh·∫•t 01 h·ªì s∆° x√©t tuy·ªÉn th·∫≥ng
   - Trong m·ªói h·ªì s∆°, th√≠ sinh c√≥ th·ªÉ ƒëƒÉng k√Ω t·ªëi ƒëa 03 nguy·ªán v·ªçng v√†o 03 ng√†nh h·ªçc kh√°c nhau

3. **Th·ª© t·ª± x√©t tuy·ªÉn**: 
   - C√°c nguy·ªán v·ªçng s·∫Ω ƒë∆∞·ª£c x√©t theo th·ª© t·ª± ∆∞u ti√™n t·ª´ tr√™n xu·ªëng d∆∞·ªõi
   - N·∫øu tr√∫ng tuy·ªÉn nguy·ªán v·ªçng ƒë·∫ßu ti√™n, c√°c nguy·ªán v·ªçng c√≤n l·∫°i s·∫Ω kh√¥ng ƒë∆∞·ª£c x√©t

4. **H·ªì s∆° v√† minh ch·ª©ng**:
   - Cung c·∫•p ƒë·∫ßy ƒë·ªß th√¥ng tin theo y√™u c·∫ßu c·ªßa tr∆∞·ªùng
   - ƒê·∫∑c bi·ªát quan tr·ªçng: Th√¥ng tin minh ch·ª©ng cho ƒë·ªëi t∆∞·ª£ng x√©t tuy·ªÉn th·∫≥ng ph·∫£i ƒë·∫ßy ƒë·ªß v√† x√°c th·ª±c
   - H·ªì s∆° thi·∫øu th√¥ng tin ho·∫∑c th√¥ng tin kh√¥ng x√°c th·ª±c c√≥ th·ªÉ d·∫´n ƒë·∫øn vi·ªác kh√¥ng ƒë∆∞·ª£c x√©t tuy·ªÉn

üí° L∆∞u √Ω: H√£y ki·ªÉm tra k·ªπ c√°c gi·∫•y t·ªù minh ch·ª©ng tr∆∞·ªõc khi n·ªôp ƒë·ªÉ ƒë·∫£m b·∫£o quy·ªÅn l·ª£i x√©t tuy·ªÉn c·ªßa b·∫°n.
"""
        
        return intro + "\n\n<document>\n" + document_content + "\n<document>"

    def _get_xet_tuyen_rieng_process(self) -> str:
        intro = "C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t tuy·ªÉn ri√™ng:"
        
        document_content = """
# C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t tuy·ªÉn ri√™ng:

## Quy tr√¨nh ƒëƒÉng k√Ω v√† n·ªôp h·ªì s∆°:

1. **N·ªôp minh ch·ª©ng th√†nh t√≠ch**: 
   - Th√≠ sinh n·ªôp minh ch·ª©ng th√†nh t√≠ch (gi·∫£i th∆∞·ªüng h·ªçc thu·∫≠t, ch·ª©ng ch·ªâ ƒë·∫∑c bi·ªát, v.v.) tr·ª±c tuy·∫øn t·∫°i https://tuyensinh.dut.udn.vn/
   - Vi·ªác cung c·∫•p th√¥ng tin minh ch·ª©ng th√†nh t√≠ch khi n·ªôp h·ªì s∆° l√† b·∫Øt bu·ªôc

2. **ƒêƒÉng k√Ω nguy·ªán v·ªçng ch√≠nh th·ª©c**: 
   - ƒêƒÉng k√Ω nguy·ªán v·ªçng v√†o c√°c ng√†nh h·ªçc c·ªßa tr∆∞·ªùng v√†o th·ªùi ƒëi·ªÉm x√©t tuy·ªÉn chung theo quy ƒë·ªãnh c·ªßa B·ªô Gi√°o d·ª•c v√† ƒê√†o t·∫°o

3. **S·ªë l∆∞·ª£ng nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒë∆∞·ª£c ƒëƒÉng k√Ω kh√¥ng gi·ªõi h·∫°n s·ªë l∆∞·ª£ng nguy·ªán v·ªçng v√†o t·∫•t c·∫£ c√°c ng√†nh h·ªçc c·ªßa Tr∆∞·ªùng

4. **ƒêi·ªÉm ∆∞u ti√™n v√† minh ch·ª©ng**:
   - ƒê·ªÉ ƒë∆∞·ª£c h∆∞·ªüng ƒëi·ªÉm ∆∞u ti√™n, th√≠ sinh c·∫ßn cung c·∫•p ƒë·∫ßy ƒë·ªß gi·∫•y t·ªù minh ch·ª©ng li√™n quan

5. **Th·ª© t·ª± x√©t tuy·ªÉn**:
   - C√°c nguy·ªán v·ªçng ƒë∆∞·ª£c x√©t theo th·ª© t·ª± ∆∞u ti√™n t·ª´ tr√™n xu·ªëng d∆∞·ªõi 
   - N·∫øu tr√∫ng tuy·ªÉn ·ªü m·ªôt nguy·ªán v·ªçng, c√°c nguy·ªán v·ªçng c√≤n l·∫°i s·∫Ω kh√¥ng ƒë∆∞·ª£c x√©t

üí° L∆∞u √Ω: Ch·∫•t l∆∞·ª£ng minh ch·ª©ng th√†nh t√≠ch s·∫Ω ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn k·∫øt qu·∫£ x√©t tuy·ªÉn. H√£y ƒë·∫£m b·∫£o cung c·∫•p ƒë·∫ßy ƒë·ªß v√† ch√≠nh x√°c c√°c gi·∫•y t·ªù li√™n quan.
"""
        
        return intro + "\n\n<document>\n" + document_content + "\n<document>"

    def _get_tot_nghiep_thpt_process(self) -> str:
        intro = "C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t ƒëi·ªÉm thi t·ªët nghi·ªáp THPT:"
        
        document_content = """
# C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t ƒëi·ªÉm thi t·ªët nghi·ªáp THPT:

## Quy tr√¨nh ƒëƒÉng k√Ω v√† n·ªôp h·ªì s∆°:

1. **ƒêƒÉng k√Ω nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒëƒÉng k√Ω nguy·ªán v·ªçng x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i h·ªçc B√°ch khoa - ƒêHƒêN tr√™n h·ªá th·ªëng x√©t tuy·ªÉn chung c·ªßa B·ªô Gi√°o d·ª•c v√† ƒê√†o t·∫°o v√†o th·ªùi ƒëi·ªÉm quy ƒë·ªãnh

2. **S·ªë l∆∞·ª£ng nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒë∆∞·ª£c ƒëƒÉng k√Ω kh√¥ng gi·ªõi h·∫°n s·ªë l∆∞·ª£ng nguy·ªán v·ªçng v√†o c√°c ng√†nh h·ªçc c·ªßa tr∆∞·ªùng

3. **ƒêi·ªÉm ∆∞u ti√™n**: 
   - Th√≠ sinh c·∫ßn cung c·∫•p ƒë·∫ßy ƒë·ªß gi·∫•y t·ªù minh ch·ª©ng ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªüng ƒëi·ªÉm ∆∞u ti√™n (n·∫øu c√≥)

4. **Th·ª© t·ª± x√©t tuy·ªÉn**: 
   - C√°c nguy·ªán v·ªçng ƒë∆∞·ª£c x√©t theo th·ª© t·ª± ∆∞u ti√™n t·ª´ cao xu·ªëng th·∫•p
   - N·∫øu ƒë√£ tr√∫ng tuy·ªÉn v√†o m·ªôt nguy·ªán v·ªçng, c√°c nguy·ªán v·ªçng ti·∫øp theo s·∫Ω kh√¥ng ƒë∆∞·ª£c x√©t

üí° L∆∞u √Ω: Th·ªùi gian ƒëƒÉng k√Ω x√©t tuy·ªÉn theo ph∆∞∆°ng th·ª©c n√†y s·∫Ω theo l·ªãch chung c·ªßa B·ªô Gi√°o d·ª•c v√† ƒê√†o t·∫°o. H√£y c·∫≠p nh·∫≠t th√¥ng tin th∆∞·ªùng xuy√™n tr√™n trang web c·ªßa B·ªô v√† c·ªßa Tr∆∞·ªùng.
"""
        
        return intro + "\n\n<document>\n" + document_content + "\n<document>"

    def _get_hoc_ba_process(self) -> str:
        intro = "C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t k·∫øt qu·∫£ h·ªçc t·∫≠p THPT (H·ªçc b·∫°):"
        
        document_content = """
# C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t k·∫øt qu·∫£ h·ªçc t·∫≠p THPT (H·ªçc b·∫°):

## Quy tr√¨nh ƒëƒÉng k√Ω v√† n·ªôp h·ªì s∆°:

1. **ƒêƒÉng k√Ω nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒëƒÉng k√Ω nguy·ªán v·ªçng x√©t tuy·ªÉn b·∫±ng k·∫øt qu·∫£ h·ªçc t·∫≠p THPT tr√™n h·ªá th·ªëng x√©t tuy·ªÉn chung c·ªßa B·ªô Gi√°o d·ª•c v√† ƒê√†o t·∫°o v√†o th·ªùi ƒëi·ªÉm quy ƒë·ªãnh

2. **S·ªë l∆∞·ª£ng nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒë∆∞·ª£c ƒëƒÉng k√Ω kh√¥ng gi·ªõi h·∫°n s·ªë l∆∞·ª£ng nguy·ªán v·ªçng v√†o c√°c ng√†nh h·ªçc c·ªßa Tr∆∞·ªùng

3. **ƒêi·ªÉm ∆∞u ti√™n**: 
   - Th√≠ sinh c·∫ßn cung c·∫•p ƒë·∫ßy ƒë·ªß gi·∫•y t·ªù minh ch·ª©ng ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªüng ƒëi·ªÉm ∆∞u ti√™n (n·∫øu c√≥)

4. **Th·ª© t·ª± x√©t tuy·ªÉn**: 
   - C√°c nguy·ªán v·ªçng ƒë∆∞·ª£c x√©t theo th·ª© t·ª± ∆∞u ti√™n t·ª´ cao xu·ªëng th·∫•p
   - N·∫øu ƒë√£ tr√∫ng tuy·ªÉn v√†o m·ªôt nguy·ªán v·ªçng, c√°c nguy·ªán v·ªçng ti·∫øp theo s·∫Ω kh√¥ng ƒë∆∞·ª£c x√©t

üí° L∆∞u √Ω: ƒê·∫£m b·∫£o h·ªçc b·∫° c·ªßa b·∫°n ƒë∆∞·ª£c x√°c nh·∫≠n ƒë·∫ßy ƒë·ªß v√† ch√≠nh x√°c. Vi·ªác t√≠nh ƒëi·ªÉm h·ªçc b·∫° s·∫Ω d·ª±a tr√™n quy ƒë·ªãnh c·ª• th·ªÉ c·ªßa tr∆∞·ªùng, h√£y tham kh·∫£o th√™m tr√™n trang web tuy·ªÉn sinh c·ªßa Tr∆∞·ªùng.
"""
        
        return intro + "\n\n<document>\n" + document_content + "\n<document>"

    def _get_danh_gia_nang_luc_process(self) -> str:
        intro = "C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t k·∫øt qu·∫£ thi ƒë√°nh gi√° nƒÉng l·ª±c:"
        
        document_content = """
# C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t k·∫øt qu·∫£ thi ƒë√°nh gi√° nƒÉng l·ª±c:

## Quy tr√¨nh ƒëƒÉng k√Ω v√† n·ªôp h·ªì s∆°:

1. **ƒêƒÉng k√Ω nguy·ªán v·ªçng**: 
   - Th√≠ sinh s·ª≠ d·ª•ng k·∫øt qu·∫£ k·ª≥ thi ƒë√°nh gi√° nƒÉng l·ª±c c·ªßa ƒê·∫°i h·ªçc Qu·ªëc gia TP.HCM ƒë·ªÉ ƒëƒÉng k√Ω x√©t tuy·ªÉn
   - ƒêƒÉng k√Ω tr√™n h·ªá th·ªëng x√©t tuy·ªÉn chung c·ªßa B·ªô Gi√°o d·ª•c v√† ƒê√†o t·∫°o v√†o th·ªùi ƒëi·ªÉm quy ƒë·ªãnh

2. **S·ªë l∆∞·ª£ng nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒë∆∞·ª£c ƒëƒÉng k√Ω kh√¥ng gi·ªõi h·∫°n s·ªë l∆∞·ª£ng nguy·ªán v·ªçng v√†o c√°c ng√†nh h·ªçc c·ªßa tr∆∞·ªùng

3. **ƒêi·ªÉm ∆∞u ti√™n**: 
   - Th√≠ sinh c·∫ßn cung c·∫•p ƒë·∫ßy ƒë·ªß gi·∫•y t·ªù minh ch·ª©ng ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªüng ƒëi·ªÉm ∆∞u ti√™n (n·∫øu c√≥)

4. **Th·ª© t·ª± x√©t tuy·ªÉn**: 
   - C√°c nguy·ªán v·ªçng ƒë∆∞·ª£c x√©t theo th·ª© t·ª± ∆∞u ti√™n t·ª´ cao xu·ªëng th·∫•p
   - N·∫øu ƒë√£ tr√∫ng tuy·ªÉn v√†o m·ªôt nguy·ªán v·ªçng, c√°c nguy·ªán v·ªçng ti·∫øp theo s·∫Ω kh√¥ng ƒë∆∞·ª£c x√©t

üí° L∆∞u √Ω: ƒê·∫£m b·∫£o b·∫°n ƒë√£ tham gia k·ª≥ thi ƒë√°nh gi√° nƒÉng l·ª±c do ƒê·∫°i h·ªçc Qu·ªëc gia TP.HCM t·ªï ch·ª©c v√† c√≥ k·∫øt qu·∫£ h·ª£p l·ªá trong nƒÉm x√©t tuy·ªÉn. ƒêi·ªÉm ƒë√°nh gi√° nƒÉng l·ª±c c√≥ th·ªùi h·∫°n s·ª≠ d·ª•ng theo quy ƒë·ªãnh c·ªßa ƒë∆°n v·ªã t·ªï ch·ª©c thi.
"""
        
        return intro + "\n\n<document>\n" + document_content + "\n<document>"

    def _get_danh_gia_tu_duy_process(self) -> str:
        intro = "C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t k·∫øt qu·∫£ thi ƒë√°nh gi√° t∆∞ duy:"
        
        document_content = """
# C√°ch th·ª©c ƒëƒÉng k√≠ x√©t tuy·ªÉn v√†o Tr∆∞·ªùng ƒê·∫°i H·ªçc B√°ch Khoa nƒÉm 2025 theo ph∆∞∆°ng th·ª©c X√©t k·∫øt qu·∫£ thi ƒë√°nh gi√° t∆∞ duy:

## Quy tr√¨nh ƒëƒÉng k√Ω v√† n·ªôp h·ªì s∆°:

1. **ƒêƒÉng k√Ω nguy·ªán v·ªçng**: 
   - Th√≠ sinh s·ª≠ d·ª•ng k·∫øt qu·∫£ k·ª≥ thi ƒë√°nh gi√° t∆∞ duy c·ªßa ƒê·∫°i h·ªçc B√°ch khoa H√† N·ªôi ƒë·ªÉ ƒëƒÉng k√Ω x√©t tuy·ªÉn
   - ƒêƒÉng k√Ω tr√™n h·ªá th·ªëng x√©t tuy·ªÉn chung c·ªßa B·ªô Gi√°o d·ª•c v√† ƒê√†o t·∫°o v√†o th·ªùi ƒëi·ªÉm quy ƒë·ªãnh

2. **S·ªë l∆∞·ª£ng nguy·ªán v·ªçng**: 
   - Th√≠ sinh ƒë∆∞·ª£c ƒëƒÉng k√Ω kh√¥ng gi·ªõi h·∫°n s·ªë l∆∞·ª£ng nguy·ªán v·ªçng v√†o c√°c ng√†nh h·ªçc c·ªßa tr∆∞·ªùng

3. **ƒêi·ªÉm ∆∞u ti√™n**: 
   - Th√≠ sinh c·∫ßn cung c·∫•p ƒë·∫ßy ƒë·ªß gi·∫•y t·ªù minh ch·ª©ng ƒë·ªÉ ƒë∆∞·ª£c h∆∞·ªüng ƒëi·ªÉm ∆∞u ti√™n (n·∫øu c√≥)

4. **Th·ª© t·ª± x√©t tuy·ªÉn**: 
   - C√°c nguy·ªán v·ªçng ƒë∆∞·ª£c x√©t theo th·ª© t·ª± ∆∞u ti√™n t·ª´ cao xu·ªëng th·∫•p
   - N·∫øu ƒë√£ tr√∫ng tuy·ªÉn v√†o m·ªôt nguy·ªán v·ªçng, c√°c nguy·ªán v·ªçng ti·∫øp theo s·∫Ω kh√¥ng ƒë∆∞·ª£c x√©t

üí° L∆∞u √Ω: ƒê·∫£m b·∫£o b·∫°n ƒë√£ tham gia k·ª≥ thi ƒë√°nh gi√° t∆∞ duy do ƒê·∫°i h·ªçc B√°ch khoa H√† N·ªôi t·ªï ch·ª©c v√† c√≥ k·∫øt qu·∫£ h·ª£p l·ªá trong nƒÉm x√©t tuy·ªÉn. ƒêi·ªÉm ƒë√°nh gi√° t∆∞ duy c√≥ th·ªùi h·∫°n s·ª≠ d·ª•ng theo quy ƒë·ªãnh c·ªßa ƒë∆°n v·ªã t·ªï ch·ª©c thi.
"""
        
        return intro + "\n\n<document>\n" + document_content + "\n<document>"