from typing import List, Dict, Optional, Text, Any
from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from actions.graph_connector import GraphConnector
from actions.mapping_utils import normalize_major, normalize_method, normalize_achievement_field, normalize_subject, normalize_faculty  # Import c√°c h√†m ti·ªán √≠ch
from actions.mapping_utils import normalize_student_interests, normalize_personality_strengths, normalize_achievement_field, normalize_subjects_strengths, comprehensive_major_suggestion, MAJOR_MAPPING
import logging
from rasa_sdk.events import SlotSet
from rasa_sdk.events import FollowupAction

# C·∫•u h√¨nh logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

class ActionCutoffScore(Action):
    def name(self) -> str:
        return "action_cutoff_score"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
            
        # L·∫•y d·ªØ li·ªáu t·ª´ tracker
        major_input = tracker.get_slot("major")
        method_input = tracker.get_slot("method")
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng c√°c h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_input)
        method_keyword = normalize_method(method_input)

        print(f"Normalized major: {major_keyword}, Normalized method: {method_keyword}")
        logging.debug(f"Normalized major: {major_keyword}, Normalized method: {method_keyword}")
        
        # Truy v·∫•n v√† x·ª≠ l√Ω k·∫øt qu·∫£
        if major_keyword and method_keyword:
            rows = self.db.get_cutoff_by_major_and_method(major_keyword, method_keyword)
            if rows:
                message = f"**ƒêi·ªÉm chu·∫©n ph∆∞∆°ng th·ª©c {rows[0]['method']} c·ªßa ng√†nh {rows[0]['major']}**:\n"
                for row in rows:
                    message += f"- NƒÉm {row['year']}: {row['score']}\n"
                message += f"Th√≠ sinh c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {rows[0]['majorUrl']} "
            else:
                message = "‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu cho ng√†nh v√† ph∆∞∆°ng th·ª©c b·∫°n y√™u c·∫ßu."

        elif major_keyword:
            rows = self.db.get_all_cutoffs_by_major(major_keyword)
            if rows:
                message = f"üìå **ƒêi·ªÉm chu·∫©n c·ªßa ng√†nh {rows[0]['major']}**:\n"
                grouped = {}
                for row in rows:
                    grouped.setdefault(row["method"], []).append(f"  - NƒÉm {row['year']}: {row['score']}")
                for method, scores in grouped.items():
                    message += f"\nüëâ {method}:\n" + "\n".join(scores)
                message += f"B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {rows[0]['majorUrl']}"
            else:
                message = "‚ùå Kh√¥ng t√¨m th·∫•y ƒëi·ªÉm chu·∫©n cho ng√†nh b·∫°n h·ªèi."

        elif method_keyword:
            rows = self.db.get_all_cutoffs_by_method(method_keyword)
            if rows:
                message = f"üìä **ƒêi·ªÉm chu·∫©n theo ph∆∞∆°ng th·ª©c {method_keyword}**:\n"
                current_major = ""
                for row in rows:
                    if row['major'] != current_major:
                        current_major = row['major']
                        message += f"\nüìå {current_major}:\n"
                    message += f"- NƒÉm {row['year']}: {row['score']}\n"
                message += f"B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin ƒëi·ªÉm chu·∫©n c√°c ph∆∞∆°ng th·ª©c kh√°c /statistics/previous-admission"
            else:
                message = "‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o c√≥ ph∆∞∆°ng th·ª©c tuy·ªÉn sinh n√†y."
        else:
            message = "‚ùó Vui l√≤ng cung c·∫•p t√™n ng√†nh ho·∫∑c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn."

        dispatcher.utter_message(text=message)
        return []

class ActionMajorByMethod(Action):
    def name(self) -> str:
        return "action_major_by_method"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
            
        # S·ª≠ d·ª•ng h√†m normalize_method t·ª´ mapping_utils
        method_keyword = normalize_method(tracker.get_slot("method"))

        if method_keyword:
            rows = self.db.get_major_by_method(method_keyword)
            if rows:
                message = f"üìå **C√°c ng√†nh c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {rows[0]['method']}**:\n"
                for row in rows:
                    message += f"- {row['major']}\n"
                message += f"\nüí° B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn ·ªü {rows[0]['methodUrl']}"
            else:
                message = "‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o c√≥ ph∆∞∆°ng th·ª©c tuy·ªÉn sinh n√†y."
        else:
            message = "‚ùó Vui l√≤ng cung c·∫•p t√™n ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn."

        dispatcher.utter_message(text=message)
        return []

class ActionDetailMethod(Action):
    def name(self) -> str:
        return "action_detail_method"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y th√¥ng tin t·ª´ entity method trong message
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        
        # Chu·∫©n h√≥a t√™n ph∆∞∆°ng th·ª©c s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        method_keyword = normalize_method(method_entity)
        
        if method_keyword:
            # Truy v·∫•n d·ªØ li·ªáu t·ªï h·ª£p m√¥n t·ª´ Neo4j
            detail = self.db.get_detail_method(method_keyword)
            detail = detail[0] if detail else None
            if detail:
                message = f"üìö Th√¥ng tin chi ti·∫øt ph∆∞∆°ng th·ª©c {detail['method']}**:\n\n"
                message += f"{detail['description']}\n"
                message += f"\nüí° *B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin chi ti·∫øt v·ªÅ ph∆∞∆°ng th·ª©c ·ªü {detail['methodUrl']}.*"
            else:
                message = f"‚ùó Kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ph∆∞∆°ng th·ª©c **{method_keyword}**.\n\nVui l√≤ng ki·ªÉm tra l·∫°i t√™n ph∆∞∆°ng th·ª©c ho·∫∑c li√™n h·ªá v·ªõi nh√† tr∆∞·ªùng ƒë·ªÉ bi·∫øt th√™m th√¥ng tin."
        else:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n ph∆∞∆°ng th·ª©c c·ª• th·ªÉ b·∫°n mu·ªën t√¨m hi·ªÉu v·ªÅ th√¥ng tin chi ti·∫øt.\n\nV√≠ d·ª•: *\"Th√¥ng tin chi ti·∫øt ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn h·ªçc b·∫° l√† g√¨?\"*"
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionCombinationMajor(Action):
    def name(self) -> str:
        return "action_combination_major"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y th√¥ng tin t·ª´ entity major trong message
        major_entity = next(tracker.get_latest_entity_values("major"), None)
        
        # Chu·∫©n h√≥a t√™n ng√†nh s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_entity)
        
        if major_keyword:
            # Truy v·∫•n d·ªØ li·ªáu t·ªï h·ª£p m√¥n t·ª´ Neo4j
            combinations = self.db.get_combination_subjects(major_keyword)
            
            if combinations and len(combinations) > 0:
                message = f"üìö **T·ªï h·ª£p m√¥n x√©t tuy·ªÉn c·ªßa ng√†nh {combinations[0]['major']}**:\n\n"
                for idx, combo in enumerate(combinations, 1):
                    message += f"{idx}. {combo['subject_combination']}\n"
                message += f"\nüí° *B·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m th√¥ng tin c·ªßa ng√†nh n√†y ·ªü {combinations[0]['majorUrl']} .*"
            else:
                message = f"‚ùó Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ t·ªï h·ª£p m√¥n x√©t tuy·ªÉn cho ng√†nh **{major_keyword}**.\n\nVui l√≤ng ki·ªÉm tra l·∫°i t√™n ng√†nh ho·∫∑c li√™n h·ªá v·ªõi nh√† tr∆∞·ªùng ƒë·ªÉ bi·∫øt th√™m th√¥ng tin."
        else:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n ng√†nh c·ª• th·ªÉ b·∫°n mu·ªën t√¨m hi·ªÉu v·ªÅ t·ªï h·ª£p m√¥n x√©t tuy·ªÉn.\n\nV√≠ d·ª•: *\"T·ªï h·ª£p m√¥n x√©t tuy·ªÉn ng√†nh C√¥ng ngh·ªá th√¥ng tin l√† g√¨?\"*"

        dispatcher.utter_message(text=message)
        return []
    
class ActionAskMethodsForMajor(Action):
    def name(self) -> str:
        return "action_ask_methods_for_major"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y d·ªØ li·ªáu t·ª´ tracker
        major_input = tracker.get_slot("major")
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_input)
        
        print(f"Normalized major for methods: {major_keyword}")
        
        if major_keyword:
            # Truy v·∫•n ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn cho ng√†nh
            results = self.db.get_method_by_major(major_keyword)
            
            if results:
                # T·∫°o th√¥ng b√°o v·ªõi danh s√°ch c√°c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn
                major_name = results[0]["major"]
                methods = [result["method"] for result in results]
                
                message = f"üìù **Ng√†nh {major_name} x√©t tuy·ªÉn b·∫±ng c√°c ph∆∞∆°ng th·ª©c sau:**\n\n"
                
                for i, method in enumerate(methods, 1):
                    message += f"{i}. {method}\n"
                
                if len(methods) == 0:
                    message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn cho ng√†nh {major_input}."
                message += f"üí° B·∫°n c√≥ th·ªÉ xem th√™m th√¥ng tin c·ªßa ng√†nh {results[0]['majorUrl']}"
            else:
                message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn cho ng√†nh {major_input}."
        else:
            message = "‚ùì Vui l√≤ng cung c·∫•p t√™n ng√†nh c·ª• th·ªÉ ƒë·ªÉ t√¥i c√≥ th·ªÉ t√¨m ki·∫øm th√¥ng tin v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn."
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionAskIfMajorAcceptsMethod(Action):
    def name(self) -> str:
        return "action_ask_if_major_accepts_method"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y d·ªØ li·ªáu t·ª´ tracker
        major_input = tracker.get_slot("major")
        method_input = tracker.get_slot("method")
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu s·ª≠ d·ª•ng c√°c h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_input)
        method_keyword = normalize_method(method_input)
        
        print(f"Normalized major: {major_keyword}, Normalized method: {method_keyword}")
        
        if major_keyword and method_keyword:
            # Ki·ªÉm tra xem ng√†nh c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
            result = self.db.check_major_has_method(major_keyword, method_keyword)
            
            if result["exists"]:
                message = f"‚úÖ **C√≥, ng√†nh {result['major_name']} c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {result['method_name']}.**"
                message += f"\n\nüí° B·∫°n c√≥ th·ªÉ xem th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {result['majorUrl']}"
            else:
                if result["major_name"] and result["method_name"]:
                    message = f"‚ùå **Kh√¥ng, ng√†nh {result['major_name']} kh√¥ng x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {result['method_name']}.**"
                    message += f"\n\nüí° B·∫°n c√≥ th·ªÉ xem th√™m c√°c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn v·ªÅ ng√†nh ·ªü {result['majorUrl']}"
                elif result["major_name"]:
                    message = f"‚ùå **Kh√¥ng t√¨m th·∫•y ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn \"{method_input}\" cho ng√†nh {result['major_name']}.**"
                    message += f"\n\nüí° B·∫°n c√≥ th·ªÉ xem th√™m th√¥ng tin chi ti·∫øt v·ªÅ ng√†nh ·ªü {result['majorUrl']}"
                elif result["method_name"]:
                    message = f"‚ùå **Kh√¥ng t√¨m th·∫•y ng√†nh \"{major_input}\" c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c {result['method_name']}.**"
                else:
                    message = f"‚ùå **Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ng√†nh \"{major_input}\" v√† ph∆∞∆°ng th·ª©c \"{method_input}\".**"
        else:
            if not major_keyword and not method_keyword:
                message = "‚ùì Vui l√≤ng cung c·∫•p c·∫£ t√™n ng√†nh v√† ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn ƒë·ªÉ t√¥i c√≥ th·ªÉ ki·ªÉm tra."
            elif not major_keyword:
                message = f"‚ùì Vui l√≤ng cung c·∫•p t√™n ng√†nh c·ª• th·ªÉ ƒë·ªÉ t√¥i ki·ªÉm tra c√≥ x√©t tuy·ªÉn b·∫±ng ph∆∞∆°ng th·ª©c \"{method_input}\" kh√¥ng."
            else:
                message = f"‚ùì Vui l√≤ng cung c·∫•p ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn c·ª• th·ªÉ ƒë·ªÉ t√¥i ki·ªÉm tra ng√†nh \"{major_input}\" c√≥ √°p d·ª•ng kh√¥ng."
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionGetMajorQuota(Action):
    def name(self) -> str:
        return "action_get_major_quota"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y th√¥ng tin t·ª´ entity major trong message
        major_entity = next(tracker.get_latest_entity_values("major"), None)
        
        # Chu·∫©n h√≥a t√™n ng√†nh s·ª≠ d·ª•ng h√†m t·ª´ mapping_utils
        major_keyword = normalize_major(major_entity)
        
        logging.debug(f"Normalized major for quota: {major_keyword}")
        
        if major_keyword:
            # L·∫•y th√¥ng tin v·ªÅ ch·ªâ ti√™u v√† t√™n ng√†nh t·ª´ Neo4j
            result = self.db.get_major_quota_and_name(major_keyword)
            
            if result["found"]:
                if result["quota"]:
                    message = f"üìä **Ch·ªâ ti√™u tuy·ªÉn sinh ng√†nh {result['name']}**: {result['quota']} sinh vi√™n."
                    message += f"\n\nüí° *L∆∞u √Ω: Ch·ªâ ti√™u c√≥ th·ªÉ thay ƒë·ªïi theo t·ª´ng nƒÉm, b·∫°n c√≥ th·ªÉ tham kh·∫£o th√™m chi ti·∫øt v·ªÅ ng√†nh ·ªü {result['majorUrl']}.*"
                else:
                    message = f"‚ùó Ng√†nh {result['name']} hi·ªán ch∆∞a c√≥ th√¥ng tin v·ªÅ ch·ªâ ti√™u tuy·ªÉn sinh."
            else:
                message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ng√†nh \"{major_entity}\"."
        else:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n ng√†nh c·ª• th·ªÉ b·∫°n mu·ªën bi·∫øt v·ªÅ ch·ªâ ti√™u tuy·ªÉn sinh.\n\nV√≠ d·ª•: *\"Ch·ªâ ti√™u ng√†nh C√¥ng ngh·ªá th√¥ng tin l√† bao nhi√™u?\"*"
            
        dispatcher.utter_message(text=message)
        return []
    
class ActionSuggestMajorByAchievement(Action):
    def name(self) -> str:
        return "action_major_by_achievement"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:

        # L·∫•y th√¥ng tin v·ªÅ th√†nh t√≠ch/s·ªü tr∆∞·ªùng t·ª´ entity
        achievement = next(tracker.get_latest_entity_values("achievement"), None)
        
        logging.debug(f"Achievement input: {achievement}")
        
        if not achievement:
            message = "‚ùì Vui l√≤ng cho bi·∫øt th√†nh t√≠ch, s·ªü tr∆∞·ªùng ho·∫∑c lƒ©nh v·ª±c b·∫°n gi·ªèi ƒë·ªÉ t√¥i c√≥ th·ªÉ g·ª£i √Ω ng√†nh ph√π h·ª£p."
            dispatcher.utter_message(text=message)
            return []
        
        # Chu·∫©n h√≥a v√† ph√¢n lo·∫°i th√†nh t√≠ch/s·ªü tr∆∞·ªùng
        achievement_type = normalize_achievement_field(achievement)
        logging.debug(f"Normalized achievement: {achievement_type}")
        
        # Truy v·∫•n c√°c ng√†nh ph√π h·ª£p v·ªõi th√†nh t√≠ch/s·ªü tr∆∞·ªùng
        majors = self.db.get_major_by_achievement(achievement_type)
        
        if majors:
            message = f"üéØ **D·ª±a tr√™n th√†nh t√≠ch c·ªßa b·∫°n v·ªÅ {achievement_type}, nh·ªØng ng√†nh sau b·∫°n c√≥ th·ªÉ x√©t tuy·ªÉn:**\n\n"
            
            for i, major_info in enumerate(majors, 1):
                message += f"{i}. {major_info['major']}\n"
            
            message += "\nüí° *B·∫°n c√≥ th·ªÉ tham kh·∫£o ph∆∞∆°ng th·ª©c tuy·ªÉn sinh b·∫±ng x√©t tuy·ªÉn ri√™ng ·ªü /admission/xettuyenrieng v√† x√©t tuy·ªÉn th·∫≥ng ·ªü /admission/xettuyenthang *"
        else:
            message = f"‚ùó Th√†nh t√≠ch '{achievement_type} kh√¥ng t√¨m th·∫•y ng√†nh ph√π h·ª£p'.\n\nVui l√≤ng chia s·∫ª th√™m v·ªÅ th√†nh t√≠ch kh√°c ƒë·ªÉ t√¥i t∆∞ v·∫•n t·ªët h∆°n."
        
        dispatcher.utter_message(text=message)
        return []

class ActionDefaultFallback(Action):
    def name(self) -> str:
        return "action_default_fallback"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # ƒê·∫øm s·ªë l·∫ßn fallback li√™n ti·∫øp
        fallback_count = 0
        for event in reversed(tracker.events):
            if event.get("name") == "action_default_fallback":
                fallback_count += 1
            elif event.get("name") not in ["action_listen", None]:
                break
        
        if fallback_count >= 2:
            # N·∫øu fallback nhi·ªÅu l·∫ßn li√™n ti·∫øp -> ƒë·ªÅ ngh·ªã chuy·ªÉn ng∆∞·ªùi h·ªó tr·ª£
            dispatcher.utter_message(
                text="C√≥ v·∫ª nh∆∞ t√¥i kh√¥ng th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa b·∫°n. "
                     "B·∫°n mu·ªën ƒë∆∞·ª£c k·∫øt n·ªëi v·ªõi c√°n b·ªô t∆∞ v·∫•n tuy·ªÉn sinh kh√¥ng?")
            
            # ƒê·∫∑t m·ªôt slot ƒë·ªÉ theo d√µi y√™u c·∫ßu handoff
            return [SlotSet("handoff_requested", True)]
        else:
            # Fallback th√¥ng th∆∞·ªùng v·ªõi g·ª£i √Ω
            dispatcher.utter_message(
                text="Xin l·ªói, t√¥i kh√¥ng hi·ªÉu √Ω c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ th·ª≠ c√°c c√¢u h·ªèi nh∆∞:\n"
                     "- ƒêi·ªÉm chu·∫©n ng√†nh C√¥ng ngh·ªá th√¥ng tin nƒÉm 2024?\n"
                     "- Ng√†nh CNTT ƒë·∫∑c th√π l√† g√¨?\n"
                     "- T·ªï h·ª£p m√¥n x√©t tuy·ªÉn ng√†nh CNTT?\n"
                     "- C√°c ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn nƒÉm nay l√† g√¨?")
            
            return []

# Th√™m action handoff ƒë√£ ƒëi·ªÅu ch·ªânh
class ActionHandoffToHuman(Action):
    def name(self) -> str:
        return "action_handoff_to_human"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # Th√¥ng b√°o h∆∞·ªõng d·∫´n theo y√™u c·∫ßu
        dispatcher.utter_message(
            text="ƒê·ªÉ k·∫øt n·ªëi v·ªõi c√°n b·ªô t∆∞ v·∫•n, vui l√≤ng truy c·∫≠p v√†o m·ª•c t∆∞ v·∫•n tuy·ªÉn sinh tr√™n website.")
        
        # Reset slot handoff_requested
        return [SlotSet("handoff_requested", False)]

# Th√™m action tr√≠ch xu·∫•t th√¥ng tin t·ª´ ng·ªØ c·∫£nh
class ActionExtractFromContext(Action):
    def name(self) -> str:
        return "action_extract_from_context"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y message hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng
        user_message = tracker.latest_message.get("text", "").lower()
        
        # Tr√≠ch xu·∫•t ng·ªØ c·∫£nh hi·ªán t·∫°i
        current_major = tracker.get_slot("current_context_major")
        current_method = tracker.get_slot("current_context_method")
        
        # C√°c t·ª´ kh√≥a x√°c nh·∫≠n/ph·ªß ƒë·ªãnh
        affirm_keywords = ["c√≥", "ƒë√∫ng", "v√¢ng", "ok", "ƒë∆∞·ª£c", "mu·ªën", "t·∫•t nhi√™n", "ch·∫Øc ch·∫Øn"]
        deny_keywords = ["kh√¥ng", "ƒë·ª´ng", "th√¥i", "kh·ªèi", "ch∆∞a", "kh√¥ng c·∫ßn"]
        
        # Ki·ªÉm tra n·∫øu c√≥ x√°c nh·∫≠n/ph·ªß ƒë·ªãnh trong tin nh·∫Øn
        is_affirm = any(keyword in user_message for keyword in affirm_keywords)
        is_deny = any(keyword in user_message for keyword in deny_keywords)
        
        # N·∫øu c√≥ x√°c nh·∫≠n v√† ƒëang c√≥ major trong ng·ªØ c·∫£nh
        if is_affirm and current_major:
            if "t·ªï h·ª£p" in user_message or "m√¥n" in user_message:
                # Chuy·ªÉn h∆∞·ªõng sang action tr·∫£ l·ªùi v·ªÅ t·ªï h·ª£p m√¥n
                return [FollowupAction("action_combination_major")]
            
            elif "ph∆∞∆°ng th·ª©c" in user_message or "x√©t tuy·ªÉn" in user_message:
                # Chuy·ªÉn sang tr·∫£ l·ªùi v·ªÅ ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn
                return [FollowupAction("action_ask_methods_for_major")]
        
        # N·∫øu ph·ªß ƒë·ªãnh ho·∫∑c kh√¥ng r√µ √Ω ng∆∞·ªùi d√πng
        if is_deny or not (is_affirm or is_deny):
            dispatcher.utter_message(
                text="B·∫°n c·∫ßn t∆∞ v·∫•n th√™m th√¥ng tin g√¨ v·ªÅ tuy·ªÉn sinh?")
        
        return []

class ActionSuggestMajorBySubjects(Action):
    def name(self) -> str:
        return "action_suggest_major_by_subjects"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y t·∫•t c·∫£ c√°c entity subject t·ª´ message hi·ªán t·∫°i
        subjects = list(tracker.get_latest_entity_values("subject"))
        
        logging.debug(f"Raw subjects from entities: {subjects}")
        
        # N·∫øu kh√¥ng t√¨m th·∫•y subject trong entities, th·ª≠ t√¨m trong to√†n b·ªô message
        if not subjects:
            user_message = tracker.latest_message.get("text", "")
            from actions.mapping_utils import find_subjects_in_text
            subjects = find_subjects_in_text(user_message)
            logging.debug(f"Subjects extracted from message: {subjects}")
        
        # Chu·∫©n h√≥a c√°c m√¥n h·ªçc
        normalized_subjects = []
        for subject in subjects:
            normalized_subject = normalize_subject(subject)
            if normalized_subject and normalized_subject not in normalized_subjects:
                normalized_subjects.append(normalized_subject)
        
        logging.debug(f"Normalized subjects: {normalized_subjects}")
        
        if not normalized_subjects:
            message = "‚ùì Vui l√≤ng cho bi·∫øt c√°c m√¥n h·ªçc b·∫°n mu·ªën x√©t tuy·ªÉn ƒë·ªÉ t√¥i c√≥ th·ªÉ g·ª£i √Ω ng√†nh ph√π h·ª£p.\n\n" \
                      "V√≠ d·ª•: \"*T√¥i mu·ªën x√©t tuy·ªÉn b·∫±ng m√¥n To√°n, L√Ω, H√≥a th√¨ c√≥ th·ªÉ ƒëƒÉng k√Ω ng√†nh n√†o?*\""
            dispatcher.utter_message(text=message)
            return []
        
        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng m√¥n h·ªçc t·ªëi ƒëa l√† 4
        if len(normalized_subjects) > 4:
            normalized_subjects = normalized_subjects[:4]
            logging.debug(f"Limited to max 4 subjects: {normalized_subjects}")
        
        # Truy v·∫•n c√°c ng√†nh ph√π h·ª£p v·ªõi c√°c m√¥n h·ªçc ƒë√£ chu·∫©n h√≥a
        majors = self.db.get_majors_by_subjects(normalized_subjects)
        logging.debug(f"Got {len(majors)} results from Neo4j")
        
        if majors:
            # Danh s√°ch c√°c m√¥n ƒë√£ ch·ªçn
            subjects_str = ", ".join([f"**{subject}**" for subject in normalized_subjects])
            
            message = f"üìö **C√°c ng√†nh ph√π h·ª£p v·ªõi m√¥n {subjects_str}:**\n\n"
            
            # X·ª≠ l√Ω k·∫øt qu·∫£ tr·ª±c ti·∫øp t·ª´ Neo4j, kh√¥ng c·∫ßn gom nh√≥m l·∫°i
            major_count = 0
            for i, record in enumerate(majors, 1):
                # Chuy·ªÉn Neo4j record th√†nh dict ƒë·ªÉ d·ªÖ x·ª≠ l√Ω
                major_info = dict(record)
                
                # L·∫•y th√¥ng tin c∆° b·∫£n
                major_name = major_info.get('major')
                major_id = major_info.get('major_id')
                major_url = major_info.get('majorUrl')
                
                
                if not major_name:
                    continue
                
                major_count += 1
                message += f"{major_count}. {major_name}\n"
                
                # X·ª≠ l√Ω v√† hi·ªÉn th·ªã c√°c t·ªï h·ª£p m√¥n
                subject_combinations = major_info.get('subject_combinations', [])
                
                if subject_combinations and len(subject_combinations) > 0:
                    message += "   *T·ªï h·ª£p m√¥n*:\n"
                    for combo in subject_combinations:
                        message += f"   - {combo}\n"
                else:
                    message += "   *T·ªï h·ª£p m√¥n*: Th√¥ng tin kh√¥ng c√≥ s·∫µn\n"
                
                message += f"Xem chi ti·∫øt ng√†nh n√†y {major_url}\n"
                
            
            # Th√™m g·ª£i √Ω
            message += "\nüí° B·∫°n c√≥ th·ªÉ xem chi ti·∫øt v·ªÅ ph∆∞∆°ng th·ª©c x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp trung h·ªçc ph·ªï th√¥ng /admission/totnghiep_thpt"
        else:
            subjects_str = ", ".join(normalized_subjects)
            message = f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o ph√π h·ª£p v·ªõi m√¥n **{subjects_str}**.\n\n" \
                      f"C√≥ th·ªÉ t·ªï h·ª£p m√¥n n√†y kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong x√©t tuy·ªÉn ho·∫∑c th√¥ng tin ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong h·ªá th·ªëng.\n\n" \
                      f"üí° B·∫°n c√≥ th·ªÉ th·ª≠ v·ªõi c√°c m√¥n ph·ªï bi·∫øn nh∆∞: **To√°n, L√Ω, H√≥a** ho·∫∑c **To√°n, VƒÉn, Anh**."
        
        dispatcher.utter_message(text=message)
        
        # L∆∞u l·∫°i b·ªëi c·∫£nh ƒë·ªÉ x·ª≠ l√Ω theo d√µi
        if "current_subjects" in domain.get("slots", {}):
            return [SlotSet("current_subjects", normalized_subjects)]
        return []
    
class ActionGetMajorsByFaculty(Action):
    def name(self) -> str:
        return "action_get_majors_by_faculty"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y faculty t·ª´ entity ho·∫∑c slot
        faculty_entity = next(tracker.get_latest_entity_values("faculty"), None)
        faculty_slot = tracker.get_slot("faculty")
        
        # ∆Øu ti√™n entity trong message hi·ªán t·∫°i, n·∫øu kh√¥ng c√≥ th√¨ d√πng slot
        faculty = faculty_entity or faculty_slot
        
        logging.debug(f"Faculty input: {faculty}")
        
        if not faculty:
            message = "‚ùì Vui l√≤ng cho bi·∫øt t√™n khoa b·∫°n mu·ªën t√¨m hi·ªÉu v·ªÅ c√°c ng√†nh ƒë√†o t·∫°o.\n\n" \
                      "V√≠ d·ª•: \"*Khoa C√¥ng ngh·ªá th√¥ng tin c√≥ nh·ªØng ng√†nh n√†o?*\" ho·∫∑c \"*C√°c ng√†nh thu·ªôc khoa ƒêi·ªán?*\""
            dispatcher.utter_message(text=message)
            return []
        
        # Chu·∫©n h√≥a faculty ƒë·ªÉ l·∫•y ID
        faculty_id = normalize_faculty(faculty)
        faculty_id = int(faculty_id)
        logging.debug(f"Normalized faculty ID: {faculty_id}")
        
        if not faculty_id:
            message = f"‚ùå T√¥i kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ Khoa \"{faculty}\". Vui l√≤ng ki·ªÉm tra l·∫°i t√™n khoa."
            dispatcher.utter_message(text=message)
            return []
            
        # L·∫•y danh s√°ch ng√†nh t·ª´ khoa
        majors = self.db.get_majors_by_faculty(faculty_id)
        
        if not majors or len(majors) == 0:
            message = f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ c√°c ng√†nh thu·ªôc Khoa n√†y. C√≥ th·ªÉ d·ªØ li·ªáu ch∆∞a ƒë∆∞·ª£c c·∫≠p nh·∫≠t."
            dispatcher.utter_message(text=message)
            return []
            
        # T·∫°o message hi·ªÉn th·ªã danh s√°ch ng√†nh
        faculty_name = majors[0]["faculty"]
        message = f"üè´ **C√°c ng√†nh ƒë√†o t·∫°o thu·ªôc khoa {faculty_name}:**\n\n"
        
        for i, major in enumerate(majors, 1):
            message += f"{i}. {major['major']}. Xem chi ti·∫øt ng√†nh {major['majorUrl']}\n"
            
        message += "\nüí° *B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ ƒëi·ªÉm chu·∫©n, t·ªï h·ª£p m√¥n ho·∫∑c th√¥ng tin chi ti·∫øt c·ªßa t·ª´ng ng√†nh.*"
        
        dispatcher.utter_message(text=message)
        
        # L∆∞u th√¥ng tin v√†o slot ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
        return []
    
class ActionSuggestMajorByScore(Action):
    def name(self) -> str:
        return "action_suggest_major_by_score"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y ƒëi·ªÉm s·ªë t·ª´ entity
        score_entity = next(tracker.get_latest_entity_values("score"), None)
        
        # L·∫•y ph∆∞∆°ng th·ª©c t·ª´ entity v√† chu·∫©n h√≥a
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        
        if not score_entity:
            dispatcher.utter_message(text="‚ùì Vui l√≤ng cho bi·∫øt s·ªë ƒëi·ªÉm b·∫°n ƒë·∫°t ƒë∆∞·ª£c.")
            return []
        
        if not method_entity:
            dispatcher.utter_message(text="‚ùì Vui l√≤ng cho bi·∫øt ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn b·∫°n quan t√¢m.")
            return []
        
        try:
            # Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm sang s·ªë
            score = float(score_entity)
            
            # Chu·∫©n h√≥a ph∆∞∆°ng th·ª©c
            method_id = normalize_method(method_entity)
            
            if not method_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra ph∆∞∆°ng th·ª©c '{method_entity}'. "
                                            f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, "
                                            f"x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c, ƒë√°nh gi√° t∆∞ duy ho·∫∑c x√©t tuy·ªÉn ri√™ng.")
                return []
            
            # L·∫•y k·∫øt qu·∫£ g·ª£i √Ω ng√†nh
            results = self.db.get_majors_by_score_and_method(score, method_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o ph√π h·ª£p v·ªõi ƒëi·ªÉm s·ªë {score} "
                                            f"theo ph∆∞∆°ng th·ª©c {method_entity}.")
                return []
            
            # L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
            results = self._filter_valid_majors(results, method_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå T√¥i ƒë√£ t√¨m th·∫•y m·ªôt s·ªë ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm s·ªë c·ªßa b·∫°n, "
                                            f"nh∆∞ng kh√¥ng c√≥ ng√†nh n√†o c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c {method_entity} "
                                            f"trong nƒÉm h·ªçc hi·ªán t·∫°i.")
                return []
            
            # T·∫°o ph·∫£n h·ªìi
            message = self._create_response_message(results, score, method_entity)
            
            dispatcher.utter_message(text=message)
            
            return [
                SlotSet("score", score_entity),
                SlotSet("method", method_entity)
            ]
            
        except ValueError:
            dispatcher.utter_message(text=f"‚ùå ƒêi·ªÉm s·ªë '{score_entity}' kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë.")
            return []
    
    def _filter_valid_majors(self, grouped_results: list, method_id: str) -> list:
        """
        L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
        """
        if not grouped_results:
            return []
        
        filtered_groups = []
        
        for group in grouped_results:
            valid_majors = []
            for major in group["majors"]:
                # Ki·ªÉm tra xem ng√†nh c√≥ c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
                check_result = self.db.check_major_has_method(major["major_id"], method_id)
                
                # N·∫øu ph∆∞∆°ng th·ª©c v·∫´n ƒë∆∞·ª£c √°p d·ª•ng, gi·ªØ l·∫°i ng√†nh n√†y
                if check_result["exists"]:
                    valid_majors.append(major)
                else:
                    logging.debug(f"Major {major['major_name']} ({major['major_id']}) no longer uses method {method_id}")
            
            # Ch·ªâ th√™m nh√≥m v√†o k·∫øt qu·∫£ n·∫øu c√≥ ng√†nh h·ª£p l·ªá
            if valid_majors:
                filtered_groups.append({
                    "group": group["group"],
                    "majors": valid_majors
                })
        
        return filtered_groups
    
    def _create_response_message(self, grouped_results: list, score: float, method: str) -> str:
        """
        T·∫°o th√¥ng ƒëi·ªáp ph·∫£n h·ªìi t·ª´ k·∫øt qu·∫£ ƒë√£ nh√≥m
        """
        message = f"üìä **C√°c ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} theo ph∆∞∆°ng th·ª©c {method}:**\n\n"
        
        # Th√¥ng tin v·ªÅ c√°c nh√≥m
        group_info = {
            "high": "üî• **T·ª∑ l·ªá ƒë·ªó cao**",
            "medium": "‚ö° **T·ª∑ l·ªá ƒë·ªó trung b√¨nh**",
            "low": "‚ö†Ô∏è **T·ª∑ l·ªá ƒë·ªó th·∫•p**"
        }
        
        group_desc = {
            "high": "*(ƒêi·ªÉm chu·∫©n g·∫ßn v·ªõi ƒëi·ªÉm c·ªßa b·∫°n, ch√™nh l·ªách r·∫•t √≠t)*",
            "medium": "*(ƒêi·ªÉm chu·∫©n c√°ch ƒëi·ªÉm c·ªßa b·∫°n m·ªôt kho·∫£ng v·ª´a ph·∫£i)*", 
            "low": "*(ƒêi·ªÉm chu·∫©n c√°ch ƒëi·ªÉm c·ªßa b·∫°n kh√° xa)*"
        }
        
        for group in grouped_results:
            group_name = group["group"]
            majors = group["majors"]
            
            if majors:
                message += f"{group_info.get(group_name, 'Kh√°c')} {group_desc.get(group_name, '')}:\n\n"
                
                for i, major in enumerate(majors, 1):
                    message += f"{i}. {major['major_name']}. Xem chi ti·∫øt ng√†nh {major['major_url']}\n"
                
                message += "\n"
        
        message += "üí° *K·∫øt qu·∫£ d·ª±a tr√™n ƒëi·ªÉm chu·∫©n quy ƒë·ªïi t·ª´ nƒÉm 2023 v√† 2024 v·ªõi t·ª∑ l·ªá 1:4. C√°c ng√†nh ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·ªÅu √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm h·ªçc hi·ªán t·∫°i.*\n\n"
        message += "B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ:\n"
        message += "- T·ªï h·ª£p m√¥n x√©t tuy·ªÉn c·ªßa ng√†nh\n"
        message += "- ƒêi·ªÉm chu·∫©n c·ªßa ng√†nh theo c√°c nƒÉm"
        
        return message
    
class ActionSuggestMajorByScoreWithMethodAndFaculty(Action):
    def name(self) -> str:
        return "action_suggest_major_by_score_with_method_and_faculty"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y c√°c entity t·ª´ message
        score_entity = next(tracker.get_latest_entity_values("score"), None)
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        faculty_entity = next(tracker.get_latest_entity_values("faculty"), None)
        
        # Ki·ªÉm tra c√°c entity c·∫ßn thi·∫øt
        missing_entities = []
        if not score_entity:
            missing_entities.append("ƒëi·ªÉm s·ªë")
        if not method_entity:
            missing_entities.append("ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn")
        if not faculty_entity:
            missing_entities.append("khoa")
            
        if missing_entities:
            missing_str = ", ".join(missing_entities)
            message = f"‚ùì Vui l√≤ng cung c·∫•p {missing_str} ƒë·ªÉ t√¥i c√≥ th·ªÉ t∆∞ v·∫•n ng√†nh ph√π h·ª£p."
            dispatcher.utter_message(text=message)
            return []
        
        try:
            # Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm sang s·ªë
            score = float(score_entity)
            
            # Chu·∫©n h√≥a ph∆∞∆°ng th·ª©c v√† khoa
            method_id = normalize_method(method_entity)
            faculty_id = normalize_faculty(faculty_entity)
            faculty_id = int(faculty_id)
            
            if not method_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra ph∆∞∆°ng th·ª©c '{method_entity}'. "
                                            f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, "
                                            f"x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c, ƒë√°nh gi√° t∆∞ duy ho·∫∑c x√©t tuy·ªÉn ri√™ng.")
                return []
                
            if not faculty_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra khoa '{faculty_entity}'. "
                                            f"Vui l√≤ng ki·ªÉm tra l·∫°i t√™n khoa.")
                return []
            
            # L·∫•y k·∫øt qu·∫£ g·ª£i √Ω ng√†nh
            results = self.db.get_majors_by_score_method_and_faculty(score, method_id, faculty_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o thu·ªôc khoa n√†y c√≥ ƒëi·ªÉm chu·∫©n "
                                            f"theo ph∆∞∆°ng th·ª©c {method_entity}.")
                return []
            
            # L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
            results = self._filter_valid_majors(results, method_id)
            
            if not results:
                dispatcher.utter_message(text=f"‚ùå T√¥i ƒë√£ t√¨m th·∫•y m·ªôt s·ªë ng√†nh thu·ªôc khoa n√†y, "
                                            f"nh∆∞ng kh√¥ng c√≥ ng√†nh n√†o c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c {method_entity} "
                                            f"trong nƒÉm h·ªçc hi·ªán t·∫°i.")
                return []
            
            # T√¨m t√™n khoa ƒë·ªÉ hi·ªÉn th·ªã
            faculty_name = None
            for group in results:
                for major in group["majors"]:
                    # L·∫•y t√™n khoa t·ª´ b·∫•t k·ª≥ major n√†o
                    faculty_name_query = self.db.get_faculty_name_by_id(faculty_id)
                    if faculty_name_query:
                        faculty_name = faculty_name_query
                        break
                if faculty_name:
                    break
            
            if not faculty_name:
                faculty_name = faculty_entity
            
            # T·∫°o ph·∫£n h·ªìi
            message = self._create_response_message(results, score, method_entity, faculty_name)
            
            dispatcher.utter_message(text=message)
            
            return []
            
        except ValueError:
            dispatcher.utter_message(text=f"‚ùå ƒêi·ªÉm s·ªë '{score_entity}' kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë.")
            return []
    
    def _filter_valid_majors(self, grouped_results: list, method_id: str) -> list:
        """
        L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
        """
        if not grouped_results:
            return []
        
        filtered_groups = []
        
        for group in grouped_results:
            valid_majors = []
            for major in group["majors"]:
                # Ki·ªÉm tra xem ng√†nh c√≥ c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
                check_result = self.db.check_major_has_method(major["major_id"], method_id)
                
                # N·∫øu ph∆∞∆°ng th·ª©c v·∫´n ƒë∆∞·ª£c √°p d·ª•ng, gi·ªØ l·∫°i ng√†nh n√†y
                if check_result["exists"]:
                    valid_majors.append(major)
                else:
                    logging.debug(f"Major {major['major_name']} ({major['major_id']}) no longer uses method {method_id}")
            
            # Ch·ªâ th√™m nh√≥m v√†o k·∫øt qu·∫£ n·∫øu c√≥ ng√†nh h·ª£p l·ªá
            if valid_majors:
                filtered_groups.append({
                    "group": group["group"],
                    "majors": valid_majors
                })
        
        return filtered_groups
    
    def _create_response_message(self, grouped_results: list, score: float, method: str, faculty_name: str) -> str:
        """
        T·∫°o th√¥ng ƒëi·ªáp ph·∫£n h·ªìi t·ª´ k·∫øt qu·∫£ ƒë√£ nh√≥m
        """
        message = f"üìä **C√°c ng√†nh thu·ªôc khoa {faculty_name} ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} theo ph∆∞∆°ng th·ª©c {method}:**\n\n"
        
        # Th√¥ng tin v·ªÅ c√°c nh√≥m
        group_info = {
            "high": "üî• **Kh·∫£ nƒÉng ƒë·ªó cao**",
            "medium": "‚ö° **Kh·∫£ nƒÉng ƒë·ªó trung b√¨nh**",
            "low": "‚ö†Ô∏è **Kh·∫£ nƒÉng ƒë·ªó th·∫•p**"
        }
        
        group_desc = {
            "high": "*(ƒêi·ªÉm chu·∫©n g·∫ßn v·ªõi ƒëi·ªÉm c·ªßa b·∫°n, ch√™nh l·ªách r·∫•t √≠t)*",
            "medium": "*(ƒêi·ªÉm chu·∫©n c√°ch ƒëi·ªÉm c·ªßa b·∫°n m·ªôt kho·∫£ng v·ª´a ph·∫£i)*", 
            "low": "*(ƒêi·ªÉm chu·∫©n c√°ch ƒëi·ªÉm c·ªßa b·∫°n kh√° xa)*"
        }
        
        for group in grouped_results:
            group_name = group["group"]
            majors = group["majors"]
            
            if majors:
                message += f"{group_info.get(group_name, 'Kh√°c')} {group_desc.get(group_name, '')}:\n\n"
                
                for i, major in enumerate(majors, 1):
                    message += f"{i}. {major['major_name']}. Xem chi ti·∫øt ng√†nh {major['major_url']}\n"
                
                message += "\n"
        
        message += "üí° *K·∫øt qu·∫£ d·ª±a tr√™n ƒëi·ªÉm chu·∫©n quy ƒë·ªïi t·ª´ nƒÉm 2023 v√† 2024 v·ªõi t·ª∑ l·ªá 1:4. C√°c ng√†nh ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·ªÅu √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm h·ªçc hi·ªán t·∫°i.*\n\n"
        message += "B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ:\n"
        message += "- T·ªï h·ª£p m√¥n x√©t tuy·ªÉn c·ªßa ng√†nh\n"
        message += "- C∆° h·ªôi vi·ªác l√†m c·ªßa c√°c ng√†nh n√†y"
        
        return message

class ActionSuggestMajorByScoreAndSubjects(Action):
    def name(self) -> str:
        return "action_suggest_major_by_score_and_subjects"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y ƒëi·ªÉm s·ªë t·ª´ entity
        score_entity = next(tracker.get_latest_entity_values("score"), None)
        
        # L·∫•y ph∆∞∆°ng th·ª©c t·ª´ entity
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        
        # L·∫•y c√°c m√¥n h·ªçc t·ª´ entity
        subjects = list(tracker.get_latest_entity_values("subject"))
        
        # Ki·ªÉm tra c√°c th√¥ng tin c·∫ßn thi·∫øt
        missing_info = []
        if not score_entity:
            missing_info.append("ƒëi·ªÉm s·ªë")
        if not method_entity:
            missing_info.append("ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn")
        if not subjects or len(subjects) == 0:
            missing_info.append("c√°c m√¥n h·ªçc/kh·ªëi thi")
            
        if missing_info:
            missing_str = ", ".join(missing_info)
            message = f"‚ùì Vui l√≤ng cung c·∫•p {missing_str} ƒë·ªÉ t√¥i c√≥ th·ªÉ t∆∞ v·∫•n ng√†nh ph√π h·ª£p."
            dispatcher.utter_message(text=message)
            return []
        
        # Chu·∫©n h√≥a c√°c m√¥n h·ªçc
        normalized_subjects = []
        for subject in subjects:
            normalized_subject = normalize_subject(subject)
            if normalized_subject and normalized_subject not in normalized_subjects:
                normalized_subjects.append(normalized_subject)
        
        logging.debug(f"Normalized subjects: {normalized_subjects}")
        
        if not normalized_subjects:
            message = "‚ùì Vui l√≤ng cung c·∫•p t√™n c√°c m√¥n h·ªçc h·ª£p l·ªá ƒë·ªÉ t√¥i c√≥ th·ªÉ t∆∞ v·∫•n ng√†nh ph√π h·ª£p."
            dispatcher.utter_message(text=message)
            return []
        
        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng m√¥n t·ªëi ƒëa l√† 3 (kh·ªëi thi th∆∞·ªùng g·ªìm 3 m√¥n)
        if len(normalized_subjects) > 3:
            normalized_subjects = normalized_subjects[:3]
            logging.debug(f"Limited to 3 subjects for combination: {normalized_subjects}")
        
        try:
            # Chuy·ªÉn ƒë·ªïi ƒëi·ªÉm sang s·ªë
            score = float(score_entity)
            
            # Chu·∫©n h√≥a ph∆∞∆°ng th·ª©c
            method_id = normalize_method(method_entity)
            
            if not method_id:
                dispatcher.utter_message(text=f"‚ùå T√¥i kh√¥ng nh·∫≠n ra ph∆∞∆°ng th·ª©c '{method_entity}'. "
                                            f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, "
                                            f"x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c, ƒë√°nh gi√° t∆∞ duy ho·∫∑c x√©t tuy·ªÉn ri√™ng.")
                return []
            
            # L·∫•y k·∫øt qu·∫£ g·ª£i √Ω ng√†nh
            results = self.db.get_majors_by_score_method_and_subjects(score, method_id, normalized_subjects)
            
            if not results:
                subjects_str = ", ".join(normalized_subjects)
                dispatcher.utter_message(text=f"‚ùå Kh√¥ng t√¨m th·∫•y ng√†nh n√†o ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} "
                                            f"theo ph∆∞∆°ng th·ª©c {method_entity} "
                                            f"v√† t·ªï h·ª£p m√¥n {subjects_str}.")
                return []
            
            # L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
            results = self._filter_valid_majors(results, method_id)
            
            if not results:
                subjects_str = ", ".join(normalized_subjects)
                dispatcher.utter_message(text=f"‚ùå T√¥i ƒë√£ t√¨m th·∫•y m·ªôt s·ªë ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} "
                                            f"v√† t·ªï h·ª£p m√¥n {subjects_str}, "
                                            f"nh∆∞ng kh√¥ng c√≥ ng√†nh n√†o c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c {method_entity} "
                                            f"trong nƒÉm h·ªçc hi·ªán t·∫°i.")
                return []
            
            # T·∫°o ph·∫£n h·ªìi
            subjects_str = ", ".join(normalized_subjects)
            message = self._create_response_message(results, score, method_entity, subjects_str)
            
            dispatcher.utter_message(text=message)
            
            return [
                SlotSet("score", score_entity),
                SlotSet("method", method_entity),
                SlotSet("current_subjects", normalized_subjects)
            ]
            
        except ValueError:
            dispatcher.utter_message(text=f"‚ùå ƒêi·ªÉm s·ªë '{score_entity}' kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë.")
            return []
    
    def _filter_valid_majors(self, grouped_results: list, method_id: str) -> list:
        """
        L·ªçc k·∫øt qu·∫£ ƒë·ªÉ ch·ªâ gi·ªØ l·∫°i c√°c ng√†nh v·∫´n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm hi·ªán t·∫°i
        """
        if not grouped_results:
            return []
        
        filtered_groups = []
        
        for group in grouped_results:
            valid_majors = []
            for major in group["majors"]:
                # Ki·ªÉm tra xem ng√†nh c√≥ c√≤n √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y kh√¥ng
                check_result = self.db.check_major_has_method(major["major_id"], method_id)
                
                # N·∫øu ph∆∞∆°ng th·ª©c v·∫´n ƒë∆∞·ª£c √°p d·ª•ng, gi·ªØ l·∫°i ng√†nh n√†y
                if check_result["exists"]:
                    valid_majors.append(major)
                else:
                    logging.debug(f"Major {major['major_name']} ({major['major_id']}) no longer uses method {method_id}")
            
            # Ch·ªâ th√™m nh√≥m v√†o k·∫øt qu·∫£ n·∫øu c√≥ ng√†nh h·ª£p l·ªá
            if valid_majors:
                filtered_groups.append({
                    "group": group["group"],
                    "majors": valid_majors
                })
        
        return filtered_groups
    
    def _create_response_message(self, grouped_results: list, score: float, method: str, subjects_str: str) -> str:
        """
        T·∫°o th√¥ng ƒëi·ªáp ph·∫£n h·ªìi t·ª´ k·∫øt qu·∫£ ƒë√£ nh√≥m
        """
        message = f"üìä C√°c ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm {score} theo ph∆∞∆°ng th·ª©c {method} v√† t·ªï h·ª£p m√¥n {subjects_str}:\n\n"
        
        # Th√¥ng tin v·ªÅ c√°c nh√≥m
        group_info = {
            "high": "üî• T·ª∑ l·ªá ƒë·ªó cao",
            "medium": "‚ö° T·ª∑ l·ªá ƒë·ªó trung b√¨nh",
            "low": "‚ö†Ô∏è T·ª∑ l·ªá ƒë·ªó th·∫•p"
        }
        
        group_desc = {
            "high": "(ƒêi·ªÉm chu·∫©n g·∫ßn v·ªõi ƒëi·ªÉm c·ªßa b·∫°n, ch√™nh l·ªách r·∫•t √≠t)",
            "medium": "(ƒêi·ªÉm chu·∫©n c√°ch ƒëi·ªÉm c·ªßa b·∫°n m·ªôt kho·∫£ng v·ª´a ph·∫£i)", 
            "low": "(ƒêi·ªÉm chu·∫©n c√°ch ƒëi·ªÉm c·ªßa b·∫°n kh√° xa)"
        }
        
        for group in grouped_results:
            group_name = group["group"]
            majors = group["majors"]
            
            if majors:
                message += f"{group_info.get(group_name, 'Kh√°c')} {group_desc.get(group_name, '')}:\n\n"
                
                for i, major in enumerate(majors, 1):
                    message += f"{i}. {major['major_name']}. Xem chi ti·∫øt ng√†nh {major['major_url']}\n"
                
                message += "\n"
        
        message += "üí° *K·∫øt qu·∫£ d·ª±a tr√™n ƒëi·ªÉm chu·∫©n quy ƒë·ªïi t·ª´ nƒÉm 2023 v√† 2024 v·ªõi t·ª∑ l·ªá 1:4 v√† t·ªï h·ª£p m√¥n ph√π h·ª£p. C√°c ng√†nh ƒë∆∞·ª£c hi·ªÉn th·ªã ƒë·ªÅu √°p d·ª•ng ph∆∞∆°ng th·ª©c n√†y trong nƒÉm h·ªçc hi·ªán t·∫°i.*\n\n"
        message += "B·∫°n c√≥ th·ªÉ h·ªèi th√™m v·ªÅ:\n"
        message += "- Th√¥ng tin chi ti·∫øt v·ªÅ t·ª´ng ng√†nh\n"
        message += "- C∆° h·ªôi vi·ªác l√†m c·ªßa c√°c ng√†nh n√†y\n"
        message += "- ƒêi·ªÉm chu·∫©n theo c√°c nƒÉm"
        
        return message

class ActionGetAdmissionProcessByMethod(Action):
    def name(self) -> str:
        return "action_get_admission_process_by_method"

    def __init__(self):
        self.db = GraphConnector()

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
            
        # L·∫•y ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn t·ª´ entity ho·∫∑c slot
        method_entity = next(tracker.get_latest_entity_values("method"), None)
        method_slot = tracker.get_slot("method")
        
        # ∆Øu ti√™n entity trong message hi·ªán t·∫°i, n·∫øu kh√¥ng c√≥ th√¨ d√πng slot
        method = method_entity or method_slot
        
        if not method:
            dispatcher.utter_message(text="‚ùì Vui l√≤ng cho bi·∫øt ph∆∞∆°ng th·ª©c x√©t tuy·ªÉn b·∫°n mu·ªën t√¨m hi·ªÉu quy tr√¨nh ƒëƒÉng k√Ω.")
            return []
        
        # Chu·∫©n h√≥a method ƒë·ªÉ l·∫•y ID
        method_id = normalize_method(method)
        
        if not method_id:
            message = (f"‚ùå T√¥i kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ quy tr√¨nh ƒëƒÉng k√Ω cho ph∆∞∆°ng th·ª©c \"{method}\". "
                      f"Vui l√≤ng th·ª≠ l·∫°i v·ªõi c√°c ph∆∞∆°ng th·ª©c nh∆∞: x√©t tuy·ªÉn th·∫≥ng, x√©t tuy·ªÉn ri√™ng, "
                      f"x√©t ƒëi·ªÉm thi t·ªët nghi·ªáp, x√©t h·ªçc b·∫°, ƒë√°nh gi√° nƒÉng l·ª±c ho·∫∑c ƒë√°nh gi√° t∆∞ duy.")
            dispatcher.utter_message(text=message)
            return []
        
        # L·∫•y quy tr√¨nh ƒëƒÉng k√Ω cho ph∆∞∆°ng th·ª©c t∆∞∆°ng ·ª©ng
        method_details = self.db.get_detail_method(method_id)
        method_detail = method_details[0] if method_details else None
        if not method_details:
            dispatcher.utter_message(text=f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt cho ph∆∞∆°ng th·ª©c \"{method}\".")
            return []
        else:
            message = f"üè´ **Quy tr√¨nh ƒëƒÉng k√Ω x√©t tuy·ªÉn theo ph∆∞∆°ng th·ª©c {method_detail['method']}:**\n\n"
            message += "<document>\n"
            message += method_detail["application_process"]
            message += "\n<document>"
            message += f"\n\nüí° *L∆∞u √Ω: Th√≠ sinh tham kh·∫£o th√¥ng tin chi ti·∫øt ph∆∞∆°ng th·ª©c t·∫°i {method_detail['methodUrl']}"
            dispatcher.utter_message(text=message)
        # L∆∞u slot ƒë·ªÉ s·ª≠ d·ª•ng sau n√†y
        return []
    
class ActionCalculateScore(Action):
    def name(self) -> str:
        return "action_calculate_score"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict) -> List[Dict]:
        
        # L·∫•y t·∫•t c·∫£ c√°c entity subject v√† score t·ª´ message
        subject_entities = list(tracker.get_latest_entity_values("subject"))
        score_entities = list(tracker.get_latest_entity_values("score"))
        
        logging.debug(f"Subject entities: {subject_entities}")
        logging.debug(f"Score entities: {score_entities}")
        
        # Ki·ªÉm tra n·∫øu kh√¥ng ƒë·ªß th√¥ng tin
        if not subject_entities or not score_entities:
            dispatcher.utter_message(text="‚ùì T√¥i c·∫ßn th√¥ng tin r√µ r√†ng v·ªÅ m√¥n h·ªçc v√† ƒëi·ªÉm t∆∞∆°ng ·ª©ng ƒë·ªÉ t√≠nh to√°n. "
                                         "Vui l√≤ng cung c·∫•p ƒëi·ªÉm cho t·ª´ng m√¥n h·ªçc c·ª• th·ªÉ.")
            return []
        
        # T·∫°o dictionary m√¥n h·ªçc v√† ƒëi·ªÉm
        subjects_scores = {}
        
        # Chu·∫©n h√≥a t√™n m√¥n v√† ƒëi·ªÉm
        for i, subject in enumerate(subject_entities):
            if i >= len(score_entities):
                break
                
            # Chu·∫©n h√≥a t√™n m√¥n h·ªçc
            normalized_subject = normalize_subject(subject.lower())
            if not normalized_subject:
                continue
                
            # Chuy·ªÉn ƒëi·ªÉm s·ªë th√†nh float
            try:
                score = float(score_entities[i])
                # ƒê·∫£m b·∫£o ƒëi·ªÉm n·∫±m trong kho·∫£ng h·ª£p l·ªá
                if 0 <= score <= 10:
                    # L√†m tr√≤n ƒë·∫øn 2 ch·ªØ s·ªë th·∫≠p ph√¢n
                    subjects_scores[normalized_subject] = round(score, 2)
            except ValueError:
                continue
        
        # N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá
        if not subjects_scores:
            dispatcher.utter_message(text="‚ùå Kh√¥ng th·ªÉ t√≠nh to√°n ƒëi·ªÉm v·ªõi d·ªØ li·ªáu ƒë√£ cung c·∫•p. "
                                         "Vui l√≤ng ƒë·∫£m b·∫£o ƒëi·ªÉm s·ªë h·ª£p l·ªá (t·ª´ 0 ƒë·∫øn 10).")
            return []
            
        if len(subjects_scores) > 8:
            # Ch·ªâ l·∫•y 6 m√¥n ƒë·∫ßu ti√™n
            limited_subjects = dict(list(subjects_scores.items())[:8])
            subjects_scores = limited_subjects
        
        # T·∫°o URL ƒë·ªÉ chia s·∫ª
        share_url = self.create_share_url(subjects_scores)
        
        # T·∫°o c√¢u tr·∫£ l·ªùi
        message = self.create_response_message(subjects_scores, share_url)
        
        dispatcher.utter_message(text=message)
        
        return []
    
    def create_share_url(self, subjects_scores: dict) -> str:
        """T·∫°o URL chia s·∫ª ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ truy c·∫≠p tool t√≠nh ƒëi·ªÉm"""
        params = []
        for subject, score in subjects_scores.items():
            params.append(f"{subject}={score}")
        
        return f"/calculatescore/thpt?{'&'.join(params)}"
    
    def create_response_message(self, subjects_scores: dict, share_url: str) -> str:
        """T·∫°o th√¥ng b√°o ph·∫£n h·ªìi v·ªõi k·∫øt qu·∫£ t√≠nh to√°n"""
        # Hi·ªÉn th·ªã th√¥ng tin m√¥n h·ªçc ƒë√£ nh·∫≠p
        message = "üìö **Th√¥ng tin ƒëi·ªÉm c√°c m√¥n:**\n\n"
        for subject, score in subjects_scores.items():
            message += f"- {subject.capitalize()}: {score}\n"
        
        # Th√™m URL cho c√¥ng c·ª• t√≠nh to√°n chi ti·∫øt
        message += f"\nüí° ƒêi·ªÉm c·ªßa c√°c kh·ªëi x√©t tuy·ªÉn t·ª´ ƒëi·ªÉm c·ªßa b·∫°n c√≥ th·ªÉ truy c·∫≠p '{share_url}'"
        
        return message
    
class ActionSuggestMajorsByStrengths(Action):
    def name(self) -> Text:
        return "action_suggest_majors_by_strengths"
        
    def __init__(self):
        self.db = GraphConnector()
        
    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:
        
        # L·∫•y th√¥ng tin v·ªÅ s·ªü th√≠ch t·ª´ slot
        interests_text = tracker.get_slot("student_interests")
        academic_strengths_text = tracker.get_slot("academic_strengths") 
        personality_text = tracker.get_slot("personality_traits")
        
        # N·∫øu kh√¥ng c√≥ th√¥ng tin, y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p
        if not interests_text and not academic_strengths_text and not personality_text:
            message = (
                "ƒê·ªÉ g·ª£i √Ω ng√†nh h·ªçc ph√π h·ª£p, h√£y cho t√¥i bi·∫øt v·ªÅ s·ªü th√≠ch, "
                "ƒëi·ªÉm m·∫°nh h·ªçc t·∫≠p ho·∫∑c t√≠nh c√°ch c·ªßa b·∫°n. V√≠ d·ª•:\n\n"
                "‚Ä¢ \"*Em th√≠ch l·∫≠p tr√¨nh, c√¥ng ngh·ªá v√† gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ*\"\n" 
                "‚Ä¢ \"*Em gi·ªèi to√°n, l√Ω v√† th√≠ch l√†m vi·ªác v·ªõi m√°y t√≠nh*\"\n"
                "‚Ä¢ \"*Em l√† ng∆∞·ªùi t·ªâ m·ªâ, ki√™n nh·∫´n v√† th√≠ch kh√°m ph√° c√°i m·ªõi*\""
            )
            dispatcher.utter_message(text=message)
            return []
        
        # Ph√¢n t√≠ch v√† chu·∫©n h√≥a d·ªØ li·ªáu ƒë·∫ßu v√†o
        interests = []
        if interests_text:
            interests = normalize_student_interests(interests_text)
            
        academic_strengths = []
        if academic_strengths_text:
            academic_strengths = normalize_subjects_strengths(academic_strengths_text)
            
        personality_traits = []
        if personality_text:
            personality_traits = normalize_personality_strengths(personality_text)
        
        # Ghi log cho vi·ªác debug
        logging.debug(f"S·ªü th√≠ch: {interests}")
        logging.debug(f"ƒêi·ªÉm m·∫°nh h·ªçc t·∫≠p: {academic_strengths}")
        logging.debug(f"T√≠nh c√°ch: {personality_traits}")
        
        # N·∫øu kh√¥ng t√¨m th·∫•y b·∫•t k·ª≥ th√¥ng tin g·ª£i √Ω n√†o
        if not interests and not academic_strengths and not personality_traits:
            message = (
                "T√¥i ch∆∞a th·ªÉ x√°c ƒë·ªãnh r√µ s·ªü th√≠ch v√† ƒëi·ªÉm m·∫°nh c·ªßa b·∫°n. H√£y chia s·∫ª c·ª• th·ªÉ h∆°n v·ªÅ:\n\n"
                "‚Ä¢ C√°c m√¥n h·ªçc b·∫°n th√≠ch v√† gi·ªèi (nh∆∞ to√°n, l√Ω, h√≥a, sinh...)\n"
                "‚Ä¢ S·ªü th√≠ch (nh∆∞ l·∫≠p tr√¨nh, m√°y t√≠nh, x√¢y d·ª±ng, thi·∫øt k·∫ø...)\n"
                "‚Ä¢ T√≠nh c√°ch v√† k·ªπ nƒÉng (nh∆∞ th√≠ch gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ, l√†m vi·ªác nh√≥m, t·ªâ m·ªâ...)"
            )
            dispatcher.utter_message(text=message)
            return []
        
        # T·∫°o g·ª£i √Ω t·ªïng h·ª£p
        suggestions = comprehensive_major_suggestion(
            interests, 
            academic_strengths, 
            personality_traits
        )
        
        if not suggestions:
            message = (
                "T√¥i ch∆∞a t√¨m th·∫•y ng√†nh h·ªçc ph√π h·ª£p v·ªõi th√¥ng tin b·∫°n cung c·∫•p. "
                "H√£y cung c·∫•p th√™m th√¥ng tin v·ªÅ s·ªü th√≠ch v√† ƒëi·ªÉm m·∫°nh c·ªßa b·∫°n."
            )
            dispatcher.utter_message(text=message)
            return []
        
        # L·∫•y th√™m th√¥ng tin chi ti·∫øt v·ªÅ m·ªói ng√†nh h·ªçc t·ª´ Neo4j
        major_details = {}
        for major_id in suggestions.keys():
            # L·∫•y th√¥ng tin chi ti·∫øt t·ª´ Neo4j
            details = self.db.get_major_quota_and_name(major_id)
            if details and details["found"]:
                major_details[major_id] = details
        
        # T·∫°o ph·∫£n h·ªìi
        message = "üìö **D·ª±a v√†o th√¥ng tin c·ªßa b·∫°n, c√°c ng√†nh h·ªçc ph√π h·ª£p nh·∫•t l√†:**\n\n"
        
        suggested_major_ids = []  # Danh s√°ch l∆∞u ID c·ªßa c√°c ng√†nh ƒë∆∞·ª£c g·ª£i √Ω
        
        for i, (major_id, details) in enumerate(suggestions.items(), 1):
            # Th√¥ng tin t·ª´ g·ª£i √Ω
            score = details['score']
            
            # L·∫•y th√¥ng tin chi ti·∫øt t·ª´ Neo4j n·∫øu c√≥
            if major_id in major_details:
                neo4j_details = major_details[major_id]
                major_name = neo4j_details["name"]
                quota = neo4j_details.get("quota", "Ch∆∞a c·∫≠p nh·∫≠t")
                major_url = neo4j_details.get("majorUrl", "")
                
                # Th√™m v√†o danh s√°ch ng√†nh g·ª£i √Ω
                suggested_major_ids.append(major_id)
                
                # T·∫°o th√¥ng tin hi·ªÉn th·ªã
                message += f"{i}. **{major_name}** (ƒê·ªô ph√π h·ª£p: {score*100:.0f}%)\n"
                if quota:
                    message += f"   - Ch·ªâ ti√™u: {quota}\n"
                
                # Th√™m gi·∫£i th√≠ch
                for explanation in details['explanation']:
                    message += f"   - {explanation}\n"
                
                # Th√™m link chi ti·∫øt ng√†nh h·ªçc
                if major_url:
                    message += f"   - [Xem chi ti·∫øt v·ªÅ ng√†nh h·ªçc]( {major_url} )\n"
            else:
                # N·∫øu kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt, hi·ªÉn th·ªã t√™n ng√†nh t·ª´ ID
                # Vi·∫øt hoa ch·ªØ c√°i ƒë·∫ßu c·ªßa m·ªói t·ª´ trong t√™n ng√†nh
                major_name = ' '.join(word.capitalize() for word in major_id.split('_'))
                message += f"{i}. **{major_name}** (ƒê·ªô ph√π h·ª£p: {score*100:.0f}%)\n"
                
                # Th√™m gi·∫£i th√≠ch
                for explanation in details['explanation']:
                    message += f"   - {explanation}\n"
            
            message += "\n"
        
        # Th√™m g·ª£i √Ω ti·∫øp theo
        message += (
            "üí° B·∫°n c√≥ th·ªÉ t√¨m hi·ªÉu th√™m v·ªÅ c√°c ng√†nh n√†y b·∫±ng c√°ch h·ªèi t√¥i nh∆∞:\n"
            "‚Ä¢ \"Cho em th√¥ng tin v·ªÅ ng√†nh C√¥ng Ngh·ªá Th√¥ng Tin\"\n"
            "‚Ä¢ \"T·ªï h·ª£p m√¥n n√†o x√©t tuy·ªÉn v√†o K·ªπ thu·∫≠t ƒêi·ªán t·ª≠?\"\n"
            "‚Ä¢ \"Ng√†nh K·ªπ thu·∫≠t X√¢y d·ª±ng h·ªçc nh·ªØng g√¨?\""
        )
        
        dispatcher.utter_message(text=message)
        
        # L∆∞u c√°c ng√†nh ƒë∆∞·ª£c ƒë·ªÅ xu·∫•t v√†o slot ƒë·ªÉ ti·∫øp t·ª•c tr√≤ chuy·ªán
        return [SlotSet("suggested_majors", suggested_major_ids)]